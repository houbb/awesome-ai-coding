---
title: AI SDD 开发规范-34-降低编写压力
tags: [ai, sdd, sh]
published: true
---

# AI 编程如何降低研发编写的压力，提升文档编写的压力？比如把公共的常见的方式，直接放在公共部分，而不是每次都要重新写

这是一个**典型的“结构性转移工作量”的问题**：
不是让 AI 替你多写代码，而是**把重复、低价值、易标准化的“研发负担”前移并固化为“文档资产”**，从而把压力从“每次写”转移为“一次建、长期用”。

下面我从**原则 → 架构 → 具体落地机制 → 示例**四个层次，系统回答你的问题。

---

## 一、核心原则：把“隐性约定”变成“显性公共文档”

传统研发的真实负担主要来自三类事情：

1. **重复说明“我们一贯是怎么做的”**
2. **解释“这个项目的默认假设”**
3. **为 AI / 新人 / 跨团队反复补上下文**

AI 编程时代的关键转变是：

> **不再每个需求都解释“怎么做”，
> 而是声明“除非特别说明，一律按公共规则做”。**

这本质上是：

* 从「**逐需求说明**」
  → 到「**基线规则 + 差异声明**」

---

## 二、总体架构：三层文档，把压力从“人脑”迁移到“结构”

我建议你用一个**强约束、可被 AI 执行的文档分层结构**：

### 1️⃣ 公共基线层（Once, for All）

> **一次写好，所有项目复用**

**放什么？**

* 通用技术选型约定
* 通用实现模式
* 默认行为
* 常见异常处理
* 日志、监控、错误码规范
* 命名、目录、分层、DTO / VO 约定

**典型文件：**

* `ENGINEERING_BASELINE.md`
* `COMMON_PATTERNS.md`
* `DEFAULT_BEHAVIORS.md`

> 这是**“研发不需要再写的部分”**

---

### 2️⃣ 项目约束层（Project Profile）

> **声明：这个项目和公共基线有什么不同**

**放什么？**

* 项目背景
* 技术栈偏差
* 特殊约束（性能、安全、合规）
* 不适用的公共规则

**典型文件：**

* `PROJECT_PROFILE.md`

> 这是**“只写差异，不写常规”**

---

### 3️⃣ 需求执行层（Design / Task）

> **只描述“变化”与“新增”**

**放什么？**

* 新功能逻辑
* 特殊分支
* 与公共模式的偏离点
* 必须覆盖的边界

**典型文件：**

* `DESIGN.md`
* `TASK.md`

> 这是**研发真正需要动脑的部分**

---

## 三、关键机制：用 AI 把“默认”变成“无需再写”

下面是**真正能“降研发压力、提文档质量”的机制设计**。

---

### 机制 1：公共模式 = AI 的“隐式上下文”

你不再要求研发每次写：

> * Controller 如何写
> * Service 是否幂等
> * 异常如何抛
> * 日志打几层

而是在 `COMMON_PATTERNS.md` 中声明：

```md
## 通用接口实现模式

- Controller 仅负责参数校验与返回包装
- Service 必须保证幂等
- 所有业务异常使用 BizException
- 所有异常必须记录 error 日志
- 成功路径使用 info 日志
```

然后在 **AI 提示词中明确**：

> “除非 DESIGN.md 明确声明例外，否则一律遵循 COMMON_PATTERNS.md”

**效果：**

* 研发不用再写
* AI 也不会发散
* 审查点变少

---

### 机制 2：文档“缺省即采用”，而不是“每次重写”

强制一个规则：

> **如果文档没有写，代表使用默认公共方案**

而不是：

* 没写 = 不清楚
* 没写 = 要问

这会倒逼：

* 公共文档写清楚
* 项目文档极度简化

---

### 机制 3：用“否定式文档”代替“重复式文档”

研发最痛苦的不是写“怎么做”，而是写**“和以前一样”**。

你可以要求：

```md
## 本需求与公共规范的差异

- 不使用默认的分页查询方式（原因：XXX）
- 不使用标准错误码（原因：XXX）
```

而不是：

```md
## 实现方式
- 使用标准分页
- 使用标准错误码
```

**负担下降 50%+**

---

### 机制 4：公共文档 = AI 的“编译期依赖”

你可以明确告诉 AI：

> “公共文档视为不可修改的系统依赖，
> 如发现缺失，请提出修改建议，不得私自发明实现。”

这会产生两个好处：

1. AI 不再“临时发挥”
2. 公共文档反而持续被完善（像代码库一样演进）

---

## 四、一个完整示例（研发压力对比）

### ❌ 传统写法（研发累）

```md
## 接口说明
- 使用 Spring MVC
- 参数校验使用 @Valid
- 异常统一返回 Result
- 日志打印请求参数和响应
```

---

### ✅ AI 友好 + 低负担写法

```md
## 实现说明

- 接口实现遵循公共接口规范
- 本接口的特殊点：
  - 需要额外校验 xxx 字段
  - 异常需要额外记录 traceId
```

**前提：**

* 公共接口规范已经在 `COMMON_PATTERNS.md` 写清楚

---

## 五、最终总结一句话

> **AI 编程时代，
> 不是让研发写更多文档，
> 而是把“重复说明”变成“可复用规则”，
> 把“经验负担”升级为“公共资产”。**

如果你愿意，下一步我可以帮你直接：

* 设计一套 **“公共工程规范文档模板（AI 可执行版）”**
* 或把你现有的项目文档，**重构成“公共基线 + 差异声明”结构**



# 参考资料

