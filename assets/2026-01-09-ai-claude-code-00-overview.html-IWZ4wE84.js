import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as o,o as a}from"./app-DJMkg_fl.js";const r={};function s(i,e){return a(),n("div",null,[...e[0]||(e[0]=[o('<h2 id="说明-note" tabindex="-1"><a class="header-anchor" href="#说明-note"><span><strong>说明（Note）</strong></span></a></h2><p>本报告的全部内容均由 Claude Opus 4 生成，并在几乎所有主流旗舰模型的协助下完成。</p><p>不过，关于“本报告是如何制作的”那篇约 8000 字的过程性文章是<strong>人工撰写</strong>的——你可以从这里开始阅读：</p><p><strong>Conducting smarter intelligences than me: new orchestras</strong></p><p>需要说明的是，这并不是严格意义上的反编译或逆向工程尝试，更像是对 Claude 团队卓越工作的致敬。</p><p>文中给出的示例<strong>并不保证</strong>真实存在于 Claude Code 中（也不一定直接来源于或复制自源码）——其主要目的在于<strong>教学价值</strong>：帮助我们学习如何以新的方式编排（orchestrate）AI Agent。</p><p>（一个简短说明：感谢所有指出幻觉问题的人，但这些内容是<strong>刻意保留</strong>的，作为生成过程中的“工件”。“制作过程”的那篇文章将帮助我们理解它们为何出现；在我看来，这些幻觉同样有助于理解如何构建 Agentic 系统。）</p><p>如果你想阅读<strong>最有技术深度</strong>的部分，请从<br><strong>Novel Components: The Innovations That Define Claude Code</strong> 开始。</p><p>如果你想阅读<strong>最有趣</strong>的部分，请从<br><strong>An LLM&#39;s Perspective: What It&#39;s Actually Like to Receive These Instructions</strong> 开始。</p><hr><h2 id="说明-note-1" tabindex="-1"><a class="header-anchor" href="#说明-note-1"><span>说明（Note）</span></a></h2><h3 id="来自作者的一段说明-a-note-from-me" tabindex="-1"><a class="header-anchor" href="#来自作者的一段说明-a-note-from-me"><span>来自作者的一段说明（A Note from me）</span></a></h3><p>这个项目源于一次纯粹的好奇。我想弄清楚 Claude Code 的内部运作方式——在我看来，它是目前最优秀的 Agentic 编程工具（尽管竞争者非常接近）。最初，我以为它会很简单——无非是一个 LLM 加上一些工具，在循环中运行。但我错了。</p><p>事实证明，它要复杂得多，包含大量我未曾预料到的创新组件。</p><p>为了解析这一系统，我与多个 AI 子代理（subagents）协作，让它们分别在不同推理片段上工作。我在它们之间<strong>手动传递问题与洞见</strong>，审查输出以检查幻觉，并对结果进行二次验证。</p><p>整个过程包括：</p><ul><li>五个批次，每个批次四轮，且每一批次都使用<strong>全新的子代理</strong>（主要是 Gemini 2.5 Pro）</li><li>生成了大约 <strong>30 万 token</strong> 的中间分析内容</li><li>将所有内容压缩、整合为一份完整的综合报告</li></ul><p>令人惊讶的是，这一切只花了一天时间，却让我学到了非常多。在 LLM 出现之前，这样的分析即便可行，也可能需要数月时间。<br> 感谢 Opus 4：它接手了我压缩后的报告，并将其转化为你即将阅读的这份全面分析。</p><p>—— Hrishi</p><hr><h2 id="为什么-claude-code-很重要-why-claude-code-matters" tabindex="-1"><a class="header-anchor" href="#为什么-claude-code-很重要-why-claude-code-matters"><span>为什么 Claude Code 很重要（Why Claude Code Matters）</span></a></h2><p>Claude Code 包含多个极具价值的组成部分：</p><ul><li><strong>流式架构（Streaming Architecture）</strong>：同时处理实时 LLM 响应、工具执行与 UI 更新</li><li><strong>安全系统（Safety Systems）</strong>：在不打断工作流的前提下提供安全保障</li><li><strong>工具设计（Tool Design）</strong>：优雅地连接 AI 推理与系统执行</li><li><strong>提示工程（Prompt Engineering）</strong>：可靠地控制复杂的 LLM 行为</li></ul><p>让我们直接进入正题。下面的每个标题都链接到对应的完整章节。</p><hr><h2 id="依赖项-claude-code-架构的基石" tabindex="-1"><a class="header-anchor" href="#依赖项-claude-code-架构的基石"><span>依赖项：Claude Code 架构的基石</span></a></h2><p><strong>为什么要在终端中使用 React？这里为什么会出现 yoga-layout？</strong></p><p>探索那些非常规的依赖选择，它们正是 Claude Code 高性能的基础。了解嵌入 JSON 到 bash 命令中的自定义 shell 解析器、用于处理 LLM 部分响应的流式 JSON 解析器，以及从移动端开发中借鉴而来的 ANR（应用无响应）检测系统。</p><hr><h2 id="数据结构与信息架构" tabindex="-1"><a class="header-anchor" href="#数据结构与信息架构"><span>数据结构与信息架构</span></a></h2><p><strong>消息在系统中是如何演变的</strong></p><p>跟随数据从用户输入开始，经过 LLM 处理，再到工具执行的完整路径。理解三阶段消息表示、ContentBlock 的多态设计，以及如何通过弱引用避免内存膨胀。</p><p><strong>关键洞察（Key Insight）</strong>：<br> CliMessage 包装器在保持 API 兼容性的同时维护了 UI 状态——无需修改协议即可实现丰富的交互体验。</p><hr><h2 id="控制流与编排引擎" tabindex="-1"><a class="header-anchor" href="#控制流与编排引擎"><span>控制流与编排引擎</span></a></h2><p><strong>深入 tt 函数内部</strong></p><p>探索这个六阶段的异步生成器，它负责协调系统中的一切。了解并行工具执行是如何实现的、上下文压缩为何会自动触发，以及递归轮次如何支持无限深度的对话。</p><p><strong>关键洞察</strong>：<br> 工具会根据“副作用”进行分类——只读工具可并行执行，而写操作则为保证安全而串行执行。</p><hr><h2 id="工具系统与执行引擎" tabindex="-1"><a class="header-anchor" href="#工具系统与执行引擎"><span>工具系统与执行引擎</span></a></h2><p><strong>从 LLM 的决策到系统行为</strong></p><p>每一个工具本身都是精心设计的状态机。深入研究权限系统、进度上报与错误处理机制。重点关注 BashTool 的沙箱模式，以及 EditTool 对行号的处理方式。</p><p><strong>关键洞察</strong>：<br> AgentTool 实现了分层任务拆解（hierarchical task decomposition）——它能够生成子代理并综合它们的发现结果。</p><hr><h2 id="架构-引擎室-the-engine-room" tabindex="-1"><a class="header-anchor" href="#架构-引擎室-the-engine-room"><span>架构：引擎室（The Engine Room）</span></a></h2><p><strong>事件驱动、流式优先、安全意识内建</strong></p><p>理解从 React UI 到系统调用的分层架构。了解权限如何在不同作用域中级联传播，ANR 检测为何使用 worker 线程，以及三套遥测系统如何提供完整的可观测性。</p><p><strong>关键洞察</strong>：<br> 安全不是一个单一系统——而是多个彼此独立、能够安全失效的防护层。</p><hr><h2 id="创新组件-定义-claude-code-的关键创新" tabindex="-1"><a class="header-anchor" href="#创新组件-定义-claude-code-的关键创新"><span>创新组件：定义 Claude Code 的关键创新</span></a></h2><p><strong>解决硬问题的巧妙方案</strong></p><p>探索那些让 Claude Code 与众不同的组件：具备恢复能力的流式 JSON 解析、智能数据截断、多 Agent 结果综合机制。这些不仅是功能，而是针对基础性挑战的创新解法。</p><p><strong>关键洞察</strong>：<br> normalizeToSize 算法会基于真实字节大小，迭代式地降低对象深度——在约束条件下最大限度保留信息量。</p><hr><h2 id="文件编辑-ai-辅助的代码修改" tabindex="-1"><a class="header-anchor" href="#文件编辑-ai-辅助的代码修改"><span>文件编辑：AI 辅助的代码修改</span></a></h2><p><strong>为什么需要三种不同的编辑工具？</strong></p><p>深入文件编辑流水线。理解行号为何会引发问题、顺序编辑如何检测冲突，以及当文件在外部发生变更时系统会如何应对。</p><p><strong>关键洞察</strong>：<br> 几乎每一种可能出现的编辑错误都有对应的校验机制——从外部修改到编码问题，无一遗漏。</p><hr><h2 id="提示工程-指挥-ai-的艺术" tabindex="-1"><a class="header-anchor" href="#提示工程-指挥-ai-的艺术"><span>提示工程：指挥 AI 的艺术</span></a></h2><p><strong>让一切运转起来的指令体系</strong></p><p>分析实际用于控制 Claude Code 的提示内容。从“简洁性约束”到超过 500 字的 BashTool 安全指令，理解精心措辞如何塑造模型行为。</p><p><strong>关键洞察</strong>：<br> 重复是有效的——关键指令会出现三次，且强调力度逐级增强。</p><hr><h2 id="从-llm-的视角看-接收这些指令到底是什么体验" tabindex="-1"><a class="header-anchor" href="#从-llm-的视角看-接收这些指令到底是什么体验"><span>从 LLM 的视角看：接收这些指令到底是什么体验</span></a></h2><p><strong>站在“另一侧”看这些提示</strong></p><p>在这一独特章节中，一个 LLM（也就是“我”）坦率地讲述接收这些指令时的真实感受。为什么“只输出 4”会出乎意料地困难？为什么“-1000 美元罚款”尽管是虚构的，却能带来真实的行为改变？</p><p><strong>关键洞察</strong>：<br> 清晰的约束实际上是解放性的——它们避免了决策瘫痪和过度帮助。</p><hr><h2 id="技术主题-technical-themes" tabindex="-1"><a class="header-anchor" href="#技术主题-technical-themes"><span>技术主题（Technical Themes）</span></a></h2><p>在整个分析过程中，逐渐浮现出若干设计原则：</p><ul><li><strong>流式优先（Streaming First）</strong>：所有操作都围绕增量更新设计</li><li><strong>分层安全（Safety Through Layers）</strong>：多重、相互独立的防护机制</li><li><strong>显式指令（Explicit Instructions）</strong>：冗长的提示用于消除歧义</li><li><strong>架构优先于微优化（Architecture Over Optimization）</strong></li><li><strong>理解 LLM 心理（Understanding LLM Psychology）</strong>：利用模型的真实行为方式</li></ul><hr><h2 id="章节列表-sections" tabindex="-1"><a class="header-anchor" href="#章节列表-sections"><span>章节列表（Sections）</span></a></h2><ul><li>Dependencies: The Foundation of Claude Code&#39;s Architecture</li><li>Data Structures &amp; The Information Architecture</li><li>Control Flow &amp; The Orchestration Engine</li><li>Tools &amp; The Execution Engine</li><li>Architecture: The Engine Room</li><li>Novel Components: The Innovations That Define Claude Code</li><li>File Editing: AI-Assisted Code Modification</li><li>Prompt Engineering: The Art of Instructing AI</li><li>An LLM&#39;s Perspective: What It&#39;s Actually Like to Receive These Instructions</li></ul><hr><p>能做到这一点本身就已经非常惊人，更不用说完成所需的时间了。</p><p>我无法保证报告中的每一处细节都完全正确——也许 Claude 团队可以给出权威解读——但它整体上非常有价值，也极具启发性。</p><hr><h2 id="过程-the-process" tabindex="-1"><a class="header-anchor" href="#过程-the-process"><span>过程（The Process）</span></a></h2><p><strong>Conducting smarter intelligences than me: new orchestras</strong></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://southbridge-research.notion.site/claude-code-an-agentic-cleanroom-analysis" target="_blank" rel="noopener noreferrer">https://southbridge-research.notion.site/claude-code-an-agentic-cleanroom-analysis</a></p>',83)])])}const l=t(r,[["render",s]]),h=JSON.parse('{"path":"/posts/client/claude-code/2026-01-09-ai-claude-code-00-overview.html","title":"calude-code 分析开篇","lang":"zh-CN","frontmatter":{"title":"calude-code 分析开篇","date":"2025-03-07T00:00:00.000Z","categories":["AI"],"tags":["ai","calude-code","sh"],"published":true,"description":"说明（Note） 本报告的全部内容均由 Claude Opus 4 生成，并在几乎所有主流旗舰模型的协助下完成。 不过，关于“本报告是如何制作的”那篇约 8000 字的过程性文章是人工撰写的——你可以从这里开始阅读： Conducting smarter intelligences than me: new orchestras 需要说明的是，这并不是...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"calude-code 分析开篇\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-07T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-09T06:44:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/client/claude-code/2026-01-09-ai-claude-code-00-overview.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"calude-code 分析开篇"}],["meta",{"property":"og:description","content":"说明（Note） 本报告的全部内容均由 Claude Opus 4 生成，并在几乎所有主流旗舰模型的协助下完成。 不过，关于“本报告是如何制作的”那篇约 8000 字的过程性文章是人工撰写的——你可以从这里开始阅读： Conducting smarter intelligences than me: new orchestras 需要说明的是，这并不是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-09T06:44:59.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"calude-code"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2025-03-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-09T06:44:59.000Z"}]]},"git":{"createdTime":1767931139000,"updatedTime":1767941099000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":7.17,"words":2152},"filePathRelative":"posts/client/claude-code/2026-01-09-ai-claude-code-00-overview.md","excerpt":"<h2><strong>说明（Note）</strong></h2>\\n<p>本报告的全部内容均由 Claude Opus 4 生成，并在几乎所有主流旗舰模型的协助下完成。</p>\\n<p>不过，关于“本报告是如何制作的”那篇约 8000 字的过程性文章是<strong>人工撰写</strong>的——你可以从这里开始阅读：</p>\\n<p><strong>Conducting smarter intelligences than me: new orchestras</strong></p>\\n<p>需要说明的是，这并不是严格意义上的反编译或逆向工程尝试，更像是对 Claude 团队卓越工作的致敬。</p>","autoDesc":true}');export{l as comp,h as data};
