import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as l,o as n}from"./app-Br9pe4tt.js";const a={};function s(r,e){return n(),i("div",null,[...e[0]||(e[0]=[l(`<h1 id="ai不是可以理解自然语言吗-怎么又绕回到语法树这条路了" tabindex="-1"><a class="header-anchor" href="#ai不是可以理解自然语言吗-怎么又绕回到语法树这条路了"><span>AI不是可以理解自然语言吗？怎么又绕回到语法树这条路了</span></a></h1><p>这是一个<strong>非常本质、而且非常常见的误解点</strong>。结论先给出一句话：</p><blockquote><p><strong>AI 能“理解”自然语言，并不等于它能“可靠、可控、可执行地理解代码结构”。</strong><br> 语法树不是倒退，而是 <strong>把“理解”从概率问题，变成工程可控问题</strong>。</p></blockquote><p>下面从工程视角，分层说明为什么<strong>最终一定会回到 AST / CST / 图结构</strong>这条路。</p><h2 id="一、llm-的-理解-本质是概率-不是结构" tabindex="-1"><a class="header-anchor" href="#一、llm-的-理解-本质是概率-不是结构"><span>一、LLM 的“理解”，本质是概率，不是结构</span></a></h2><p>LLM 对自然语言（以及代码）的理解，本质是：</p><ul><li>基于 token 序列</li><li>基于上下文统计与模式匹配</li><li>输出的是**“高概率正确的文本”**</li></ul><p>这带来三个天然问题：</p><ol><li><p><strong>没有确定的结构边界</strong></p><ul><li>LLM 不“知道”函数从哪一行开始、在哪一行结束</li><li>不“知道”这个调用是静态绑定还是动态分派</li><li>不“知道”这个符号是否真的可达</li></ul></li><li><p><strong>无法保证一致性</strong></p><ul><li>同一个问题，换种问法，结果可能不同</li><li>稍微超过上下文窗口，信息就丢失</li></ul></li><li><p><strong>无法做精确修改</strong></p><ul><li>“把这个函数参数改成 optional”</li><li>“只重构这个调用链，不影响其他地方”<br> —— 这类操作，纯靠自然语言几乎不可控</li></ul></li></ol><p>👉 <strong>LLM 擅长的是“解释”和“生成”，而不是“判定”和“约束”。</strong></p><hr><h2 id="二、语法树解决的是「确定性」问题" tabindex="-1"><a class="header-anchor" href="#二、语法树解决的是「确定性」问题"><span>二、语法树解决的是「确定性」问题</span></a></h2><p>Tree-sitter / AST / CST 的核心价值只有一个词：</p><blockquote><p><strong>确定性（Determinism）</strong></p></blockquote><h3 id="语法树能做到什么" tabindex="-1"><a class="header-anchor" href="#语法树能做到什么"><span>语法树能做到什么？</span></a></h3><ol><li><p><strong>结构是确定的</strong></p><ul><li>函数、类、作用域、模块边界是明确的</li><li>起止位置是精确到字符的</li></ul></li><li><p><strong>关系是可遍历的</strong></p><ul><li>调用关系</li><li>继承关系</li><li>依赖关系</li><li>作用域遮蔽</li></ul></li><li><p><strong>错误也是结构化的</strong></p><ul><li>Tree-sitter 即使在语法错误下也能产出“部分正确”的树</li><li>这对 IDE / 自动化修改极其重要</li></ul></li></ol><blockquote><p>没有 AST，你连“我到底在改什么”都说不清。</p></blockquote><hr><h2 id="三、那为什么还要-ai-各自边界在哪里" tabindex="-1"><a class="header-anchor" href="#三、那为什么还要-ai-各自边界在哪里"><span>三、那为什么还要 AI？各自边界在哪里？</span></a></h2><p><strong>正确的架构不是「AI or AST」，而是「AI on AST」</strong>。</p><p>你可以把它理解为一条流水线：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>代码文本</span></span>
<span class="line"><span>  ↓（Tree-sitter）</span></span>
<span class="line"><span>语法树 / 图结构</span></span>
<span class="line"><span>  ↓（过滤、裁剪、子图）</span></span>
<span class="line"><span>结构化上下文</span></span>
<span class="line"><span>  ↓（LLM）</span></span>
<span class="line"><span>推理 / 生成 / 决策</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>结构化操作（修改 / 查询 / 重构）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ai-负责什么" tabindex="-1"><a class="header-anchor" href="#ai-负责什么"><span>AI 负责什么？</span></a></h3><ul><li><p>理解“意图”</p><ul><li>“我想找认证逻辑”</li><li>“这段代码是否有潜在问题”</li></ul></li><li><p>生成策略</p><ul><li>查哪些节点</li><li>生成什么查询（Cypher / SQL / DSL）</li></ul></li><li><p>给出建议</p><ul><li>优化方案</li><li>重构思路</li></ul></li></ul><h3 id="ast-图负责什么" tabindex="-1"><a class="header-anchor" href="#ast-图负责什么"><span>AST / 图负责什么？</span></a></h3><ul><li>精确定位</li><li>严格约束修改范围</li><li>保证修改后代码仍然合法</li><li>做“不能错”的事情</li></ul><hr><h2 id="四、为什么工程系统一定-绕回-语法树" tabindex="-1"><a class="header-anchor" href="#四、为什么工程系统一定-绕回-语法树"><span>四、为什么工程系统一定“绕回”语法树？</span></a></h2><p>你可以观察所有<strong>真正落地的系统</strong>：</p><ul><li>IDE（IntelliJ / VS Code）</li><li>编译器</li><li>Linter / Formatter</li><li>自动重构工具</li><li>大规模代码搜索（Google / Meta 内部）</li></ul><p><strong>无一例外：</strong></p><blockquote><p>UI / 交互层可能是自然语言<br><strong>核心层一定是 AST / IR / Graph</strong></p></blockquote><p>原因很简单：</p><ul><li>代码是<strong>形式语言</strong></li><li>形式语言必须用<strong>形式结构</strong>处理</li><li>自然语言只适合做人机接口</li></ul><hr><h2 id="五、回到你这个问题的本质" tabindex="-1"><a class="header-anchor" href="#五、回到你这个问题的本质"><span>五、回到你这个问题的本质</span></a></h2><p>你真正问的，其实是：</p><blockquote><p>“既然 AI 这么强，为什么不能直接理解代码？”</p></blockquote><p>答案是：</p><blockquote><p><strong>AI 可以“看懂”，但系统需要“保证不出错”。</strong></p></blockquote><p>当你：</p><ul><li>要做自动修改</li><li>要做大规模分析</li><li>要做企业级平台</li><li>要做 IDE / 编程助手</li></ul><p>你就一定会选择：</p><blockquote><p><strong>用 AST / Graph 作为事实基础，用 AI 作为智能决策层。</strong></p></blockquote><p>这不是回到过去，而是：</p><blockquote><p><strong>在 AI 时代，重新确认哪些东西必须是确定的。</strong></p></blockquote><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/tree-sitter/tree-sitter" target="_blank" rel="noopener noreferrer">https://github.com/tree-sitter/tree-sitter</a></p>`,48)])])}const c=t(a,[["render",s]]),h=JSON.parse('{"path":"/posts/code-graph/2026-01-05-tree-sitter-02-why.html","title":"AI 时代为什么还是需要理解语法树？","lang":"zh-CN","frontmatter":{"title":"AI 时代为什么还是需要理解语法树？","date":"2026-01-05T00:00:00.000Z","categories":["AI"],"tags":["ai","ai-coding","code-graph","sh"],"published":true,"description":"AI不是可以理解自然语言吗？怎么又绕回到语法树这条路了 这是一个非常本质、而且非常常见的误解点。结论先给出一句话： AI 能“理解”自然语言，并不等于它能“可靠、可控、可执行地理解代码结构”。 语法树不是倒退，而是 把“理解”从概率问题，变成工程可控问题。 下面从工程视角，分层说明为什么最终一定会回到 AST / CST / 图结构这条路。 一、LLM...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AI 时代为什么还是需要理解语法树？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T07:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/code-graph/2026-01-05-tree-sitter-02-why.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"AI 时代为什么还是需要理解语法树？"}],["meta",{"property":"og:description","content":"AI不是可以理解自然语言吗？怎么又绕回到语法树这条路了 这是一个非常本质、而且非常常见的误解点。结论先给出一句话： AI 能“理解”自然语言，并不等于它能“可靠、可控、可执行地理解代码结构”。 语法树不是倒退，而是 把“理解”从概率问题，变成工程可控问题。 下面从工程视角，分层说明为什么最终一定会回到 AST / CST / 图结构这条路。 一、LLM..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T07:44:04.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"code-graph"}],["meta",{"property":"article:tag","content":"ai-coding"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T07:44:04.000Z"}]]},"git":{"createdTime":1767605962000,"updatedTime":1767771844000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":3.35,"words":1005},"filePathRelative":"posts/code-graph/2026-01-05-tree-sitter-02-why.md","excerpt":"\\n<p>这是一个<strong>非常本质、而且非常常见的误解点</strong>。结论先给出一句话：</p>\\n<blockquote>\\n<p><strong>AI 能“理解”自然语言，并不等于它能“可靠、可控、可执行地理解代码结构”。</strong><br>\\n语法树不是倒退，而是 <strong>把“理解”从概率问题，变成工程可控问题</strong>。</p>\\n</blockquote>\\n<p>下面从工程视角，分层说明为什么<strong>最终一定会回到 AST / CST / 图结构</strong>这条路。</p>\\n<h2>一、LLM 的“理解”，本质是概率，不是结构</h2>\\n<p>LLM 对自然语言（以及代码）的理解，本质是：</p>","autoDesc":true}');export{c as comp,h as data};
