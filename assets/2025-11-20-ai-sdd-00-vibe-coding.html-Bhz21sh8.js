import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as l}from"./app-D83PqN3g.js";const n={};function r(s,i){return l(),e("div",null,[...i[0]||(i[0]=[a('<h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><p>“<strong>Vibe-coding</strong>”并不是一个严格定义的工程方法论，而是近一年在 AI 编程圈内逐渐形成的一种<strong>工作风格（coding style / workflow mindset）</strong>。</p><p>它描述的是：<strong>开发者以“意图 + 感觉”为核心，强依赖大模型即时生成代码，而不是从严谨设计开始的传统工程流程</strong>。</p><p>下面我从<strong>定义、形成背景、典型特征、适用场景、风险边界，以及与你目前 AI 编程实践的对比</strong>几个维度系统介绍。</p><h2 id="一、什么是-vibe-coding-一句话版" tabindex="-1"><a class="header-anchor" href="#一、什么是-vibe-coding-一句话版"><span>一、什么是 Vibe-Coding（一句话版）</span></a></h2><blockquote><p><strong>Vibe-coding = 用自然语言驱动 AI 快速生成代码，通过不断试运行和微调来“顺着感觉走”的开发方式。</strong></p></blockquote><p>它更像是：</p><ul><li>“和 AI 对话写代码”</li><li>“先跑起来，再说对不对”</li><li>“结果导向 &gt; 过程严谨”</li></ul><p>而不是：</p><ul><li>先建模 → 再设计 → 再实现 → 再验证</li></ul><hr><h2 id="二、vibe-coding-的形成背景" tabindex="-1"><a class="header-anchor" href="#二、vibe-coding-的形成背景"><span>二、Vibe-Coding 的形成背景</span></a></h2><h3 id="_1️⃣-llm-编程能力的跃迁" tabindex="-1"><a class="header-anchor" href="#_1️⃣-llm-编程能力的跃迁"><span>1️⃣ LLM 编程能力的跃迁</span></a></h3><ul><li><p>GPT-4 / Claude / Gemini 已能一次性生成：</p><ul><li>可运行代码</li><li>完整模块</li><li>小型系统骨架</li></ul></li><li><p>写代码的“边际成本”急剧下降</p></li></ul><h3 id="_2️⃣-工具形态的变化" tabindex="-1"><a class="header-anchor" href="#_2️⃣-工具形态的变化"><span>2️⃣ 工具形态的变化</span></a></h3><ul><li>Claude Code / Gemini CLI / Cursor / Copilot Chat</li><li>AI 成为 <strong>随时插话的 pair programmer</strong></li><li>修改代码 ≈ 修改提示词</li></ul><h3 id="_3️⃣-原型需求激增" tabindex="-1"><a class="header-anchor" href="#_3️⃣-原型需求激增"><span>3️⃣ 原型需求激增</span></a></h3><ul><li>MVP</li><li>Demo</li><li>内部工具</li><li>临时自动化脚本</li></ul><p>在这些场景下：</p><blockquote><p><strong>“工程最优”不如“尽快看到效果”重要</strong></p></blockquote><hr><h2 id="三、vibe-coding-的典型特征" tabindex="-1"><a class="header-anchor" href="#三、vibe-coding-的典型特征"><span>三、Vibe-Coding 的典型特征</span></a></h2><h3 id="_1️⃣-以-prompt-作为-主开发介质" tabindex="-1"><a class="header-anchor" href="#_1️⃣-以-prompt-作为-主开发介质"><span>1️⃣ 以 Prompt 作为“主开发介质”</span></a></h3><p>传统开发：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>设计文档 → IDE → Code → Debug</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Vibe-coding：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>想法 → Prompt → Code → 跑 → Prompt → 改</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Prompt 本身就像“可执行需求”。</p><hr><h3 id="_2️⃣-强试错-弱规划" tabindex="-1"><a class="header-anchor" href="#_2️⃣-强试错-弱规划"><span>2️⃣ 强试错，弱规划</span></a></h3><ul><li><p>不追求一次写对</p></li><li><p>频繁：</p><ul><li>运行</li><li>报错</li><li>复制错误贴给 AI</li></ul></li><li><p>AI 负责“补洞”</p></li></ul><p>这是一种<strong>探索式编程</strong>（exploratory programming）。</p><hr><h3 id="_3️⃣-局部正确即可-全局一致性靠运气" tabindex="-1"><a class="header-anchor" href="#_3️⃣-局部正确即可-全局一致性靠运气"><span>3️⃣ 局部正确即可，全局一致性靠运气</span></a></h3><p>常见状态：</p><ul><li><p>某个函数很好</p></li><li><p>某个模块能跑</p></li><li><p>但：</p><ul><li>风格不一致</li><li>边界条件模糊</li><li>隐性假设很多</li></ul></li></ul><hr><h3 id="_4️⃣-开发者角色发生变化" tabindex="-1"><a class="header-anchor" href="#_4️⃣-开发者角色发生变化"><span>4️⃣ 开发者角色发生变化</span></a></h3><p>从：</p><ul><li>“代码作者”</li></ul><p>变成：</p><ul><li>“<strong>意图表达者 + 结果审查者</strong>”</li></ul><p>核心能力变成：</p><ul><li>提好问题</li><li>快速判断“像不像对的”</li><li>知道什么时候该停</li></ul><hr><h2 id="四、vibe-coding-适合什么场景" tabindex="-1"><a class="header-anchor" href="#四、vibe-coding-适合什么场景"><span>四、Vibe-Coding 适合什么场景？</span></a></h2><h3 id="✅-非常适合" tabindex="-1"><a class="header-anchor" href="#✅-非常适合"><span>✅ 非常适合</span></a></h3><table><thead><tr><th>场景</th><th>原因</th></tr></thead><tbody><tr><td>Demo / PoC</td><td>快速出效果</td></tr><tr><td>小工具 / 脚本</td><td>生命周期短</td></tr><tr><td>学习新技术</td><td>低心理负担</td></tr><tr><td>数据处理 / Glue Code</td><td>可容忍粗糙</td></tr><tr><td>AI / Agent 实验</td><td>本身不稳定</td></tr></tbody></table><hr><h3 id="❌-不适合" tabindex="-1"><a class="header-anchor" href="#❌-不适合"><span>❌ 不适合</span></a></h3><table><thead><tr><th>场景</th><th>风险</th></tr></thead><tbody><tr><td>核心业务系统</td><td>技术债失控</td></tr><tr><td>高可靠系统</td><td>隐性 bug</td></tr><tr><td>多人长期协作</td><td>认知不可复制</td></tr><tr><td>合规 / 安全系统</td><td>审计困难</td></tr></tbody></table><hr><h2 id="五、vibe-coding-的核心风险" tabindex="-1"><a class="header-anchor" href="#五、vibe-coding-的核心风险"><span>五、Vibe-Coding 的核心风险</span></a></h2><h3 id="_1️⃣-它能跑-它是对的" tabindex="-1"><a class="header-anchor" href="#_1️⃣-它能跑-它是对的"><span>1️⃣ “它能跑” ≠ “它是对的”</span></a></h3><ul><li><p>LLM 极擅长生成<strong>看起来合理</strong>的代码</p></li><li><p>极不擅长保证：</p><ul><li>不变量</li><li>边界完整性</li><li>长期演化一致性</li></ul></li></ul><hr><h3 id="_2️⃣-技术债是指数级累积的" tabindex="-1"><a class="header-anchor" href="#_2️⃣-技术债是指数级累积的"><span>2️⃣ 技术债是<strong>指数级</strong>累积的</span></a></h3><ul><li><p>每一次“先不管”</p></li><li><p>都在：</p><ul><li>引入隐式假设</li><li>放大未来修改成本</li></ul></li></ul><hr><h3 id="_3️⃣-知识无法沉淀" tabindex="-1"><a class="header-anchor" href="#_3️⃣-知识无法沉淀"><span>3️⃣ 知识无法沉淀</span></a></h3><ul><li><p>逻辑存在于：</p><ul><li>Prompt 历史</li><li>AI 上下文</li></ul></li><li><p>而不是：</p><ul><li>文档</li><li>代码结构</li></ul></li></ul><hr><h2 id="六、vibe-coding-ai-编程的终点" tabindex="-1"><a class="header-anchor" href="#六、vibe-coding-ai-编程的终点"><span>六、Vibe-Coding ≠ AI 编程的终点</span></a></h2><p>这是一个<strong>非常重要的澄清点</strong>。</p><p>Vibe-coding 是：</p><ul><li><strong>低门槛起飞方式</strong></li><li><strong>探索阶段的默认模式</strong></li></ul><p>但不是：</p><ul><li>可持续工程方式</li></ul><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://mybatis.org/mybatis-3/zh_CN/sqlmap-xml.html#Parameters" target="_blank" rel="noopener noreferrer">https://mybatis.org/mybatis-3/zh_CN/sqlmap-xml.html#Parameters</a></p>',70)])])}const p=t(n,[["render",r]]),h=JSON.parse('{"path":"/posts/sdd/2025-11-20-ai-sdd-00-vibe-coding.html","title":"氛围编程 vibe-coding","lang":"zh-CN","frontmatter":{"title":"氛围编程 vibe-coding","date":"2025-11-20T00:00:00.000Z","categories":["AI"],"tags":["ai","sdd","sh"],"published":true,"description":"chat “Vibe-coding”并不是一个严格定义的工程方法论，而是近一年在 AI 编程圈内逐渐形成的一种工作风格（coding style / workflow mindset）。 它描述的是：开发者以“意图 + 感觉”为核心，强依赖大模型即时生成代码，而不是从严谨设计开始的传统工程流程。 下面我从定义、形成背景、典型特征、适用场景、风险边界，以...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"氛围编程 vibe-coding\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-27T07:02:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/sdd/2025-11-20-ai-sdd-00-vibe-coding.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"氛围编程 vibe-coding"}],["meta",{"property":"og:description","content":"chat “Vibe-coding”并不是一个严格定义的工程方法论，而是近一年在 AI 编程圈内逐渐形成的一种工作风格（coding style / workflow mindset）。 它描述的是：开发者以“意图 + 感觉”为核心，强依赖大模型即时生成代码，而不是从严谨设计开始的传统工程流程。 下面我从定义、形成背景、典型特征、适用场景、风险边界，以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-27T07:02:53.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"sdd"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2025-11-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-27T07:02:53.000Z"}]]},"git":{"createdTime":1766818973000,"updatedTime":1766818973000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":2.87,"words":861},"filePathRelative":"posts/sdd/2025-11-20-ai-sdd-00-vibe-coding.md","excerpt":"\\n<p>“<strong>Vibe-coding</strong>”并不是一个严格定义的工程方法论，而是近一年在 AI 编程圈内逐渐形成的一种<strong>工作风格（coding style / workflow mindset）</strong>。</p>\\n<p>它描述的是：<strong>开发者以“意图 + 感觉”为核心，强依赖大模型即时生成代码，而不是从严谨设计开始的传统工程流程</strong>。</p>\\n<p>下面我从<strong>定义、形成背景、典型特征、适用场景、风险边界，以及与你目前 AI 编程实践的对比</strong>几个维度系统介绍。</p>\\n<h2>一、什么是 Vibe-Coding（一句话版）</h2>","autoDesc":true}');export{p as comp,h as data};
