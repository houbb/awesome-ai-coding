import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as s,o as n}from"./app-D83PqN3g.js";const t={};function l(r,a){return n(),e("div",null,[...a[0]||(a[0]=[s(`<h1 id="隐性知识-tacit-knowledge" tabindex="-1"><a class="header-anchor" href="#隐性知识-tacit-knowledge"><span>隐性知识（Tacit Knowledge）</span></a></h1><blockquote><p><strong>AI 编程的核心瓶颈不是“不会写代码”，而是“无法自动获得、理解和持续维护隐性知识（Tacit Knowledge）”。</strong></p></blockquote><p>下面我从**什么是隐性知识 → 它为什么对 AI 特别致命 → 现有方案为什么都不够 → 可落地的系统性解决路径（工程级）**四个层次展开。</p><h2 id="一、什么是-隐性知识-在工程语境下" tabindex="-1"><a class="header-anchor" href="#一、什么是-隐性知识-在工程语境下"><span>一、什么是“隐性知识”（在工程语境下）</span></a></h2><p>在真实工程中，隐性知识不是“经验主义”，而是大量<strong>未被显式表达、却真实约束系统行为的事实</strong>。</p><h3 id="在代码层面-它通常表现为" tabindex="-1"><a class="header-anchor" href="#在代码层面-它通常表现为"><span>在代码层面，它通常表现为：</span></a></h3><ul><li>“这个接口不能随便改，下游有老系统”</li><li>“这里必须先查 DB 再查缓存，否则会打爆 ES”</li><li>“这个字段名历史原因不能动”</li><li>“这里 catch 了异常是为了兼容老客户端”</li><li>“这段代码很丑，但千万别重构”</li></ul><p>这些知识：</p><ul><li><strong>不在代码里</strong></li><li><strong>不在 README</strong></li><li><strong>甚至不在设计文档</strong></li><li>只存在于：<br> 👉 人的脑子里 + 历史事故里</li></ul><hr><h2 id="二、为什么-隐性知识-对-ai-编程是致命的" tabindex="-1"><a class="header-anchor" href="#二、为什么-隐性知识-对-ai-编程是致命的"><span>二、为什么“隐性知识”对 AI 编程是致命的？</span></a></h2><h3 id="_1️⃣-llm-的世界是-显性文本宇宙" tabindex="-1"><a class="header-anchor" href="#_1️⃣-llm-的世界是-显性文本宇宙"><span>1️⃣ LLM 的世界是“显性文本宇宙”</span></a></h3><p>LLM 能理解的前提是：</p><blockquote><p><strong>信息必须被“说出来”</strong></p></blockquote><p>而隐性知识的本质是：</p><ul><li>默认共识</li><li>历史妥协</li><li>反复踩坑后的“禁区”</li></ul><p>👉 <strong>没人写，它就不存在</strong></p><hr><h3 id="_2️⃣-ai-极容易做-局部最优、全局灾难-的修改" tabindex="-1"><a class="header-anchor" href="#_2️⃣-ai-极容易做-局部最优、全局灾难-的修改"><span>2️⃣ AI 极容易做“局部最优、全局灾难”的修改</span></a></h3><p>典型场景：</p><blockquote><p>“我只是让 AI 优化一个方法”</p></blockquote><p>但这个方法：</p><ul><li>被某个定时任务假定是幂等的</li><li>被某个 MQ 重试逻辑依赖副作用</li><li>被某个灰度逻辑隐式调用</li></ul><p>AI 不知道这些“非显性契约”。</p><hr><h3 id="_3️⃣-隐性知识往往是-负向知识" tabindex="-1"><a class="header-anchor" href="#_3️⃣-隐性知识往往是-负向知识"><span>3️⃣ 隐性知识往往是“负向知识”</span></a></h3><p>最危险的隐性知识是：</p><ul><li>❌ 不能做什么</li><li>❌ 哪些地方不要碰</li><li>❌ 哪些 bug 是“已接受的坏味道”</li></ul><p>而 LLM 的训练目标是：</p><blockquote><p><strong>生成“看起来更好”的代码</strong></p></blockquote><p>这与“历史妥协”天然冲突。</p><hr><h2 id="三、为什么常见方案解决不了这个问题" tabindex="-1"><a class="header-anchor" href="#三、为什么常见方案解决不了这个问题"><span>三、为什么常见方案解决不了这个问题？</span></a></h2><h3 id="❌-多写点文档" tabindex="-1"><a class="header-anchor" href="#❌-多写点文档"><span>❌ “多写点文档”</span></a></h3><ul><li>人不会主动写“不要改这里”</li><li>文档很快过期</li><li>无法覆盖真实运行约束</li></ul><h3 id="❌-多喂上下文" tabindex="-1"><a class="header-anchor" href="#❌-多喂上下文"><span>❌ “多喂上下文”</span></a></h3><ul><li>隐性知识本来就不在上下文中</li><li>Prompt 不是魔法</li></ul><h3 id="❌-rag-知识库" tabindex="-1"><a class="header-anchor" href="#❌-rag-知识库"><span>❌ “RAG + 知识库”</span></a></h3><ul><li>RAG 只能检索<strong>已存在的知识</strong></li><li>对“没人写的坑”无能为力</li></ul><hr><h2 id="四、真正可行的解决方向-工程级" tabindex="-1"><a class="header-anchor" href="#四、真正可行的解决方向-工程级"><span>四、真正可行的解决方向（工程级）</span></a></h2><p>下面是重点：<strong>不是一个方案，而是一组协同机制</strong>。</p><hr><h2 id="_1️⃣-把-隐性知识-强制转化为-显性约束" tabindex="-1"><a class="header-anchor" href="#_1️⃣-把-隐性知识-强制转化为-显性约束"><span>1️⃣ 把“隐性知识”强制转化为“显性约束”</span></a></h2><p>不是写说明，而是<strong>变成 AI 必须遵守的规则</strong>。</p><h3 id="你的-gemini-md-本质已经在做这件事" tabindex="-1"><a class="header-anchor" href="#你的-gemini-md-本质已经在做这件事"><span>你的 <a href="http://GEMINI.md" target="_blank" rel="noopener noreferrer">GEMINI.md</a> 本质已经在做这件事</span></a></h3><p>可以进一步升级为：</p><h4 id="📌-《ai-行为约束清单》" tabindex="-1"><a class="header-anchor" href="#📌-《ai-行为约束清单》"><span>📌 《AI 行为约束清单》</span></a></h4><p>示例：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## 不可修改区域（Hard Constraints）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 不允许重构 auth 模块</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 不允许修改 public DTO 字段名</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 不允许引入新依赖</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 不允许改变接口返回结构</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>👉 <strong>禁止比建议更重要</strong></p><hr><h2 id="_2️⃣-用-失败史-作为一等知识源" tabindex="-1"><a class="header-anchor" href="#_2️⃣-用-失败史-作为一等知识源"><span>2️⃣ 用“失败史”作为一等知识源</span></a></h2><p>隐性知识最密集的地方是哪里？</p><blockquote><p><strong>事故、Bug、回滚、线上问题</strong></p></blockquote><h3 id="工程化做法" tabindex="-1"><a class="header-anchor" href="#工程化做法"><span>工程化做法：</span></a></h3><ul><li><p>每个严重 Bug：</p><ul><li>根因</li><li>为什么当初这样设计</li><li>如果 AI 来改，哪里会踩雷</li></ul></li></ul><p>沉淀为：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## Known Traps / Historical Landmines</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 2021-05: 修改缓存 key 导致全量失效</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 2022-11: 改动超时策略引发雪崩</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>👉 <strong>这是 AI 最有价值的训练语料</strong></p><hr><h2 id="_3️⃣-设计-澄清优先-的-ai-执行模式" tabindex="-1"><a class="header-anchor" href="#_3️⃣-设计-澄清优先-的-ai-执行模式"><span>3️⃣ 设计“澄清优先”的 AI 执行模式</span></a></h2><p>你之前提到的：</p><blockquote><p>spec-kit 的澄清阶段</p></blockquote><p>这是<strong>极其正确的方向</strong>。</p><h3 id="原则" tabindex="-1"><a class="header-anchor" href="#原则"><span>原则：</span></a></h3><blockquote><p><strong>凡是涉及行为变化，AI 必须先提问</strong></p></blockquote><p>示例规则：</p><ul><li>改接口语义 → 必须列风险</li><li>改数据结构 → 必须询问历史兼容性</li><li>改并发逻辑 → 必须假设存在隐性依赖</li></ul><p>这是在<strong>模拟资深工程师的谨慎</strong>。</p><hr><h2 id="_4️⃣-用-负例驱动-的提示词设计" tabindex="-1"><a class="header-anchor" href="#_4️⃣-用-负例驱动-的提示词设计"><span>4️⃣ 用“负例驱动”的提示词设计</span></a></h2><p>普通 Prompt：</p><blockquote><p>“请帮我优化这段代码”</p></blockquote><p>工程级 Prompt：</p><blockquote><p>“请在不破坏以下隐性约束的前提下修改，否则拒绝执行”</p></blockquote><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>如果你无法确认以下隐性约束是否成立，请先提出澄清问题，不要直接改代码。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>👉 <strong>允许 AI 拒绝执行，是成熟系统的标志</strong></p><hr><h2 id="_5️⃣-把-不能改-固化为结构-而不是靠记忆" tabindex="-1"><a class="header-anchor" href="#_5️⃣-把-不能改-固化为结构-而不是靠记忆"><span>5️⃣ 把“不能改”固化为结构，而不是靠记忆</span></a></h2><p>例如：</p><ul><li>黑盒模块（只暴露接口）</li><li>Legacy Zone（只允许 bugfix）</li><li>冻结包 / 冻结目录</li><li>编译期校验（字段、接口 hash）</li></ul><p>这本质是：</p><blockquote><p><strong>用工程手段封装隐性知识</strong></p></blockquote><hr><h2 id="六、一个非常重要的认知升级" tabindex="-1"><a class="header-anchor" href="#六、一个非常重要的认知升级"><span>六、一个非常重要的认知升级</span></a></h2><blockquote><p><strong>隐性知识不是“AI 的缺陷”，而是“工程长期不规范的成本”。</strong></p></blockquote><p>AI 只是：</p><ul><li>把这些问题<strong>提前暴露</strong></li><li>把“靠人兜底”的系统，变成“必须显性化”的系统</li></ul><hr><h2 id="七、最终结论-工程视角" tabindex="-1"><a class="header-anchor" href="#七、最终结论-工程视角"><span>七、最终结论（工程视角）</span></a></h2><p>如果我帮你总结成一句工程原则：</p><blockquote><p><strong>不要试图让 AI“理解隐性知识”，而是要让系统“不允许隐性知识存在”。</strong></p></blockquote><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,94)])])}const o=i(t,[["render",l]]),d=JSON.parse('{"path":"/posts/sdd/2025-11-20-ai-sdd-16-tacit-knowledge.html","title":"AI SDD 开发规范-21-隐性知识（Tacit Knowledge）","lang":"zh-CN","frontmatter":{"title":"AI SDD 开发规范-21-隐性知识（Tacit Knowledge）","date":"2025-11-20T00:00:00.000Z","categories":["AI"],"tags":["ai","sdd","sh"],"published":true,"description":"隐性知识（Tacit Knowledge） AI 编程的核心瓶颈不是“不会写代码”，而是“无法自动获得、理解和持续维护隐性知识（Tacit Knowledge）”。 下面我从**什么是隐性知识 → 它为什么对 AI 特别致命 → 现有方案为什么都不够 → 可落地的系统性解决路径（工程级）**四个层次展开。 一、什么是“隐性知识”（在工程语境下） 在真实...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AI SDD 开发规范-21-隐性知识（Tacit Knowledge）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-27T07:02:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/sdd/2025-11-20-ai-sdd-16-tacit-knowledge.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"AI SDD 开发规范-21-隐性知识（Tacit Knowledge）"}],["meta",{"property":"og:description","content":"隐性知识（Tacit Knowledge） AI 编程的核心瓶颈不是“不会写代码”，而是“无法自动获得、理解和持续维护隐性知识（Tacit Knowledge）”。 下面我从**什么是隐性知识 → 它为什么对 AI 特别致命 → 现有方案为什么都不够 → 可落地的系统性解决路径（工程级）**四个层次展开。 一、什么是“隐性知识”（在工程语境下） 在真实..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-27T07:02:53.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"sdd"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2025-11-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-27T07:02:53.000Z"}]]},"git":{"createdTime":1766818973000,"updatedTime":1766818973000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.22,"words":1265},"filePathRelative":"posts/sdd/2025-11-20-ai-sdd-16-tacit-knowledge.md","excerpt":"\\n<blockquote>\\n<p><strong>AI 编程的核心瓶颈不是“不会写代码”，而是“无法自动获得、理解和持续维护隐性知识（Tacit Knowledge）”。</strong></p>\\n</blockquote>\\n<p>下面我从**什么是隐性知识 → 它为什么对 AI 特别致命 → 现有方案为什么都不够 → 可落地的系统性解决路径（工程级）**四个层次展开。</p>\\n<h2>一、什么是“隐性知识”（在工程语境下）</h2>\\n<p>在真实工程中，隐性知识不是“经验主义”，而是大量<strong>未被显式表达、却真实约束系统行为的事实</strong>。</p>\\n<h3>在代码层面，它通常表现为：</h3>","autoDesc":true}');export{o as comp,d as data};
