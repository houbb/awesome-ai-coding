import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-DJMkg_fl.js";const t={};function l(h,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="tree-sitter" tabindex="-1"><a class="header-anchor" href="#tree-sitter"><span>Tree-sitter</span></a></h1><p>Tree-sitter 是一个<strong>语法解析器生成工具</strong>以及一个<strong>增量解析库</strong>。</p><p>它能够为源代码文件构建<strong>具体语法树（Concrete Syntax Tree, CST）</strong>，并且在源文件被编辑时，高效地对语法树进行更新。Tree-sitter 的设计目标包括：</p><ul><li><strong>通用性</strong>：足够通用，可以解析任意编程语言</li><li><strong>高性能</strong>：性能足够高，能够在文本编辑器中做到<strong>每一次按键输入都进行解析</strong></li><li><strong>健壮性</strong>：即使在存在语法错误的情况下，也能提供有价值的解析结果</li><li><strong>无运行时依赖</strong>：其运行时库使用纯 C 语言编写，可被嵌入到任何应用程序中</li></ul><p>以下为<strong>严格、结构对齐的中文翻译</strong>，保持原有标题层级、段落结构与代码不变，仅对说明性文字进行翻译。</p><hr><h2 id="入门指南-getting-started" tabindex="-1"><a class="header-anchor" href="#入门指南-getting-started"><span>入门指南（Getting Started）</span></a></h2><h3 id="构建库-building-the-library" tabindex="-1"><a class="header-anchor" href="#构建库-building-the-library"><span>构建库（Building the Library）</span></a></h3><p>在 POSIX 系统上构建该库，只需在 Tree-sitter 目录中运行 <code>make</code>。这将生成一个名为 <strong>libtree-sitter.a</strong> 的静态库，以及对应的动态库。</p><p>或者，你也可以将该库集成到更大型项目的构建系统中，只需将一个源文件加入构建即可。该源文件在编译时需要在 include 路径中包含两个目录：</p><p><strong>源文件：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>tree-sitter/lib/src/lib.c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>include 目录：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>tree-sitter/lib/src</span></span>
<span class="line"><span>tree-sitter/lib/include</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="基本对象-the-basic-objects" tabindex="-1"><a class="header-anchor" href="#基本对象-the-basic-objects"><span>基本对象（The Basic Objects）</span></a></h3><p>在使用 Tree-sitter 时，主要涉及四种核心对象类型：<strong>语言（languages）</strong>、<strong>解析器（parsers）</strong>、<strong>语法树（syntax trees）</strong> 和 <strong>语法节点（syntax nodes）</strong>。</p><p>在 C 语言中，它们分别对应为 <code>TSLanguage</code>、<code>TSParser</code>、<code>TSTree</code> 和 <code>TSNode</code>。</p><ul><li><p><strong>TSLanguage</strong><br><code>TSLanguage</code> 是一个不透明对象，用于定义如何解析某一种特定的编程语言。每种 <code>TSLanguage</code> 的代码均由 Tree-sitter 生成。当前已有大量语言的实现，分布在 Tree-sitter GitHub 组织以及 Tree-sitter grammars GitHub 组织下的独立仓库中。关于如何创建新的语言，请参阅下一节。</p></li><li><p><strong>TSParser</strong><br><code>TSParser</code> 是一个有状态的对象，可以被分配一个 <code>TSLanguage</code>，并基于给定的源代码生成一棵 <code>TSTree</code>。</p></li><li><p><strong>TSTree</strong><br><code>TSTree</code> 表示整个源代码文件的语法树。它包含多个 <code>TSNode</code> 实例，用于描述源代码的结构。当源代码发生变化时，该语法树也可以被编辑，并用于生成新的 <code>TSTree</code>。</p></li><li><p><strong>TSNode</strong><br><code>TSNode</code> 表示语法树中的单个节点。它会跟踪该节点在源代码中的起始和结束位置，以及它与其他节点之间的关系，例如父节点、兄弟节点和子节点。</p></li></ul><hr><h3 id="示例程序-an-example-program" tabindex="-1"><a class="header-anchor" href="#示例程序-an-example-program"><span>示例程序（An Example Program）</span></a></h3><p>下面是一个使用 Tree-sitter JSON 解析器的简单 C 语言示例程序。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Filename - test-json-parser.c</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;assert.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;string.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;tree_sitter/api.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// Declare the \`tree_sitter_json\` function, which is</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// implemented by the \`tree-sitter-json\` library.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> TSLanguage </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tree_sitter_json</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Create a parser.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  TSParser </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">parser </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ts_parser_new</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Set the parser&#39;s language (JSON in this case).</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  ts_parser_set_language</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(parser, </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tree_sitter_json</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Build a syntax tree based on source code stored in a string.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">source_code </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;[1, null]&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  TSTree </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">tree </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ts_parser_parse_string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    parser,</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    NULL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    source_code,</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    strlen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(source_code)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Get the root node of the syntax tree.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  TSNode root_node </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ts_tree_root_node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(tree);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Get some child nodes.</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  TSNode array_node </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ts_node_named_child</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root_node, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  TSNode number_node </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ts_node_named_child</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(array_node, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Check that the nodes have the expected types.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">strcmp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root_node), </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;document&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">strcmp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(array_node), </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;array&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">strcmp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(number_node), </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;number&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Check that the nodes have the expected child counts.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_child_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root_node) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_child_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(array_node) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_named_child_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(array_node) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ts_node_child_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(number_node) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Print the syntax tree as an S-expression.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  char</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">string </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ts_node_string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(root_node);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Syntax tree: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%s</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, string);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Free all of the heap-allocated memory.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  free</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(string);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  ts_tree_delete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(tree);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  ts_parser_delete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(parser);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该程序在构建时需要以下三个组件：</p><ol><li><strong>Tree-sitter 的 C API</strong>（位于 <code>tree-sitter/api.h</code>，这要求在 include 路径中包含 <code>tree-sitter/lib/include</code>）</li><li><strong>Tree-sitter 库</strong>（<code>libtree-sitter.a</code>）</li><li><strong>JSON 语法的源代码</strong>，该代码会被直接编译进最终的二进制文件</li></ol><p>使用如下命令进行编译：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clang</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">                                   \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -I</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tree-sitter/lib/include</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">            \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  test-json-parser.c</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">                    \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  tree-sitter-json/src/parser.c</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">         \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  tree-sitter/libtree-sitter.a</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">          \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> test-json-parser</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行程序：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./test-json-parser</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当使用<strong>动态链接</strong>时，需要确保共享库可以通过 <code>LD_LIBRARY_PATH</code> 或系统等效的环境变量被正确加载。以下是使用动态链接进行编译的示例：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clang</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">                                   \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -I</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> tree-sitter/lib/include</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">            \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  test-json-parser.c</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">                    \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  tree-sitter-json/src/parser.c</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">         \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -ltree-sitter</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">                         \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> test-json-parser</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行程序：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./test-json-parser</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/tree-sitter/tree-sitter" target="_blank" rel="noopener noreferrer">https://github.com/tree-sitter/tree-sitter</a></p>`,35)])])}const k=i(t,[["render",l]]),d=JSON.parse('{"path":"/posts/code-graph/2026-01-05-tree-sitter-01-intro.html","title":"Tree-sitter 是一个语法解析器生成工具以及一个增量解析库。","lang":"zh-CN","frontmatter":{"title":"Tree-sitter 是一个语法解析器生成工具以及一个增量解析库。","date":"2026-01-05T00:00:00.000Z","categories":["AI"],"tags":["ai","ai-coding","code-graph","sh"],"published":true,"description":"Tree-sitter Tree-sitter 是一个语法解析器生成工具以及一个增量解析库。 它能够为源代码文件构建具体语法树（Concrete Syntax Tree, CST），并且在源文件被编辑时，高效地对语法树进行更新。Tree-sitter 的设计目标包括： 通用性：足够通用，可以解析任意编程语言 高性能：性能足够高，能够在文本编辑器中做到每...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Tree-sitter 是一个语法解析器生成工具以及一个增量解析库。\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T07:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/code-graph/2026-01-05-tree-sitter-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Tree-sitter 是一个语法解析器生成工具以及一个增量解析库。"}],["meta",{"property":"og:description","content":"Tree-sitter Tree-sitter 是一个语法解析器生成工具以及一个增量解析库。 它能够为源代码文件构建具体语法树（Concrete Syntax Tree, CST），并且在源文件被编辑时，高效地对语法树进行更新。Tree-sitter 的设计目标包括： 通用性：足够通用，可以解析任意编程语言 高性能：性能足够高，能够在文本编辑器中做到每..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T07:44:04.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"code-graph"}],["meta",{"property":"article:tag","content":"ai-coding"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T07:44:04.000Z"}]]},"git":{"createdTime":1767605962000,"updatedTime":1767771844000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":3.69,"words":1107},"filePathRelative":"posts/code-graph/2026-01-05-tree-sitter-01-intro.md","excerpt":"\\n<p>Tree-sitter 是一个<strong>语法解析器生成工具</strong>以及一个<strong>增量解析库</strong>。</p>\\n<p>它能够为源代码文件构建<strong>具体语法树（Concrete Syntax Tree, CST）</strong>，并且在源文件被编辑时，高效地对语法树进行更新。Tree-sitter 的设计目标包括：</p>\\n<ul>\\n<li><strong>通用性</strong>：足够通用，可以解析任意编程语言</li>\\n<li><strong>高性能</strong>：性能足够高，能够在文本编辑器中做到<strong>每一次按键输入都进行解析</strong></li>\\n<li><strong>健壮性</strong>：即使在存在语法错误的情况下，也能提供有价值的解析结果</li>\\n<li><strong>无运行时依赖</strong>：其运行时库使用纯 C 语言编写，可被嵌入到任何应用程序中</li>\\n</ul>","autoDesc":true}');export{k as comp,d as data};
