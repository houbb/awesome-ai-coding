import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as i,o as l}from"./app-CMaZGEzo.js";const s={};function r(t,a){return l(),e("div",null,[...a[0]||(a[0]=[i(`<h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么？</span></a></h2><p>下面我从**“为什么需要 RAG → RAG 是什么 → 核心架构 → 关键技术细节 → 常见模式 → 工程落地 → 典型误区与进阶方向”**几个层次，系统、完整地展开介绍 <strong>RAG（Retrieval-Augmented Generation，检索增强生成）</strong>。</p><p>会偏工程与架构视角，结合你过往关注的 <strong>知识库 / AI 平台 / 可落地性</strong> 来讲。</p><hr><h2 id="一、为什么需要-rag-它解决的根本问题" tabindex="-1"><a class="header-anchor" href="#一、为什么需要-rag-它解决的根本问题"><span>一、为什么需要 RAG（它解决的根本问题）</span></a></h2><h3 id="_1-llm-的三个先天限制" tabindex="-1"><a class="header-anchor" href="#_1-llm-的三个先天限制"><span>1. LLM 的三个先天限制</span></a></h3><p>即使是最强的大模型，也存在硬限制：</p><ol><li><p><strong>知识是静态的</strong></p><ul><li>训练完成后，模型“冻结”</li><li>无法天然感知你公司的内部文档、数据库、实时数据</li></ul></li><li><p><strong>上下文窗口有限</strong></p><ul><li>再大的 context，本质仍是有限</li><li>不可能把所有知识都塞进 prompt</li></ul></li><li><p><strong>幻觉（Hallucination）不可避免</strong></p><ul><li>在“不确定”时，模型倾向于“合理编造”</li></ul></li></ol><p>👉 <strong>结论</strong>：<br> LLM 很擅长“语言与推理”，但<strong>不擅长“知识存储与检索”</strong>。</p><hr><h3 id="_2-rag-的核心思想-一句话版" tabindex="-1"><a class="header-anchor" href="#_2-rag-的核心思想-一句话版"><span>2. RAG 的核心思想（一句话版）</span></a></h3><blockquote><p><strong>把「找资料」这件事交给检索系统，把「理解 + 组织语言」交给大模型。</strong></p></blockquote><p>即：</p><ul><li><strong>检索（Retrieval）</strong>：从真实、可控的数据源中找“相关事实”</li><li><strong>生成（Generation）</strong>：基于事实生成自然语言回答</li></ul><hr><h2 id="二、rag-是什么-标准定义" tabindex="-1"><a class="header-anchor" href="#二、rag-是什么-标准定义"><span>二、RAG 是什么（标准定义）</span></a></h2><p><strong>RAG（Retrieval-Augmented Generation）</strong><br> 是一种将 <strong>外部知识检索系统</strong> 与 <strong>大语言模型生成能力</strong> 结合的架构模式。</p><p>其本质不是一个模型，而是一个 <strong>系统架构范式</strong>。</p><hr><h2 id="三、rag-的标准架构-工程视角" tabindex="-1"><a class="header-anchor" href="#三、rag-的标准架构-工程视角"><span>三、RAG 的标准架构（工程视角）</span></a></h2><h3 id="_1-基本流程-最小闭环" tabindex="-1"><a class="header-anchor" href="#_1-基本流程-最小闭环"><span>1. 基本流程（最小闭环）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>用户问题</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>Query 重写 / 向量化</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>知识检索（Vector / Keyword / Hybrid）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>上下文构建（Context Assembly）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>LLM 生成答案</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>答案 + 引用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-核心组件拆解" tabindex="-1"><a class="header-anchor" href="#_2-核心组件拆解"><span>2. 核心组件拆解</span></a></h3><h4 id="_1-知识源-knowledge-source" tabindex="-1"><a class="header-anchor" href="#_1-知识源-knowledge-source"><span>（1）知识源（Knowledge Source）</span></a></h4><p>常见类型：</p><ul><li>Markdown / PDF / Word</li><li>Wiki / Confluence / Notion</li><li>代码仓库（README / API 文档）</li><li>数据库（结构化数据）</li><li>日志、告警、工单（你熟悉的领域）</li></ul><hr><h4 id="_2-数据切分-chunking" tabindex="-1"><a class="header-anchor" href="#_2-数据切分-chunking"><span>（2）数据切分（Chunking）</span></a></h4><p><strong>这是 RAG 成败的关键点之一</strong></p><p>常见策略：</p><ul><li>固定长度（如 500 tokens）</li><li>语义切分（按标题 / 段落）</li><li>滑动窗口（Overlap）</li></ul><p>设计原则：</p><ul><li><strong>太大</strong>：召回不准</li><li><strong>太小</strong>：上下文碎片化</li></ul><hr><h4 id="_3-向量化-embedding" tabindex="-1"><a class="header-anchor" href="#_3-向量化-embedding"><span>（3）向量化（Embedding）</span></a></h4><p>把文本 → 向量</p><ul><li><p>目标：<strong>语义相似度</strong></p></li><li><p>常用模型：</p><ul><li>OpenAI embeddings</li><li>bge / m3e / E5（中文场景常见）</li></ul></li><li><p>向量维度通常 768 ~ 3072</p></li></ul><hr><h4 id="_4-向量数据库-vector-store" tabindex="-1"><a class="header-anchor" href="#_4-向量数据库-vector-store"><span>（4）向量数据库（Vector Store）</span></a></h4><p>职责：<strong>近似最近邻搜索（ANN）</strong></p><p>常见选型：</p><ul><li>FAISS（本地 / 单机）</li><li>Milvus</li><li>Weaviate</li><li>Qdrant</li><li>pgvector（Postgres）</li></ul><p>工程关注点：</p><ul><li>搜索延迟</li><li>数据量</li><li>是否支持 metadata 过滤</li></ul><hr><h4 id="_5-检索策略-retrieval-strategy" tabindex="-1"><a class="header-anchor" href="#_5-检索策略-retrieval-strategy"><span>（5）检索策略（Retrieval Strategy）</span></a></h4><p>不止“Top-K”这么简单：</p><ul><li>相似度检索</li><li>关键词 + 向量混合（Hybrid Search）</li><li>多路召回（Multi-Retriever）</li><li>Re-ranking（重排序）</li></ul><hr><h4 id="_6-prompt-组装-context-injection" tabindex="-1"><a class="header-anchor" href="#_6-prompt-组装-context-injection"><span>（6）Prompt 组装（Context Injection）</span></a></h4><p>把检索到的内容，<strong>以结构化方式注入 Prompt</strong></p><p>典型 Prompt 结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>System: 你是一个专业助手</span></span>
<span class="line"><span>Context:</span></span>
<span class="line"><span>  文档 1</span></span>
<span class="line"><span>  文档 2</span></span>
<span class="line"><span>  文档 3</span></span>
<span class="line"><span>Question:</span></span>
<span class="line"><span>  用户问题</span></span>
<span class="line"><span>Instruction:</span></span>
<span class="line"><span>  仅基于上述内容回答，不要编造</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="四、rag-的常见模式-从简单到复杂" tabindex="-1"><a class="header-anchor" href="#四、rag-的常见模式-从简单到复杂"><span>四、RAG 的常见模式（从简单到复杂）</span></a></h2><h3 id="_1-naive-rag-最基础" tabindex="-1"><a class="header-anchor" href="#_1-naive-rag-最基础"><span>1. Naive RAG（最基础）</span></a></h3><ul><li>单轮问题</li><li>向量检索 + 拼 Prompt</li></ul><p>适合：</p><ul><li>Demo</li><li>文档问答 PoC</li></ul><hr><h3 id="_2-advanced-rag-工程常用" tabindex="-1"><a class="header-anchor" href="#_2-advanced-rag-工程常用"><span>2. Advanced RAG（工程常用）</span></a></h3><p>增强点包括：</p><ul><li>Query Rewriting（把用户问题改写成更“可检索”的形式）</li><li>Re-ranking（Cross-Encoder）</li><li>多文档融合</li><li>引用来源</li></ul><hr><h3 id="_3-conversational-rag" tabindex="-1"><a class="header-anchor" href="#_3-conversational-rag"><span>3. Conversational RAG</span></a></h3><p>解决：</p><ul><li>多轮对话</li><li>指代消解（“刚才那个方案”）</li></ul><p>方式：</p><ul><li>历史摘要</li><li>Memory + 当前问题联合检索</li></ul><hr><h3 id="_4-agentic-rag-你后续一定会用到" tabindex="-1"><a class="header-anchor" href="#_4-agentic-rag-你后续一定会用到"><span>4. Agentic RAG（你后续一定会用到）</span></a></h3><p>把 RAG 作为 <strong>Agent 的一个 Tool</strong>：</p><ul><li><p>Agent 决定：</p><ul><li>查不查？</li><li>查哪个库？</li><li>查几次？</li></ul></li><li><p>典型场景：</p><ul><li>根因分析</li><li>复杂决策支持</li></ul></li></ul><hr><h2 id="五、rag-在你关注领域中的典型应用" tabindex="-1"><a class="header-anchor" href="#五、rag-在你关注领域中的典型应用"><span>五、RAG 在你关注领域中的典型应用</span></a></h2><h3 id="_1-企业知识库-文档助手" tabindex="-1"><a class="header-anchor" href="#_1-企业知识库-文档助手"><span>1. 企业知识库 / 文档助手</span></a></h3><ul><li>技术文档</li><li>规范 / 流程</li><li>架构设计说明</li></ul><p>👉 RAG 是<strong>唯一可控方案</strong></p><hr><h3 id="_2-运维-监控-根因分析-非常关键" tabindex="-1"><a class="header-anchor" href="#_2-运维-监控-根因分析-非常关键"><span>2. 运维 / 监控 / 根因分析（非常关键）</span></a></h3><p>RAG +：</p><ul><li>告警规则</li><li>历史事故</li><li>Runbook</li><li>专家经验</li></ul><p>形成：</p><blockquote><p><strong>“经验增强的智能诊断系统”</strong></p></blockquote><p>这与你“AI 根因分析平台”的构想是<strong>天然契合的</strong>。</p><hr><h3 id="_3-研发提效-ai-coding" tabindex="-1"><a class="header-anchor" href="#_3-研发提效-ai-coding"><span>3. 研发提效 / AI Coding</span></a></h3><ul><li>项目代码 + 设计文档 RAG</li><li>约束生成风格、架构一致性</li></ul><hr><h2 id="六、rag-的核心工程难点-真实世界" tabindex="-1"><a class="header-anchor" href="#六、rag-的核心工程难点-真实世界"><span>六、RAG 的核心工程难点（真实世界）</span></a></h2><h3 id="_1-召回不准-模型不行" tabindex="-1"><a class="header-anchor" href="#_1-召回不准-模型不行"><span>1. 召回不准 ≠ 模型不行</span></a></h3><p>80% 的问题出在：</p><ul><li>切分策略</li><li>Query 表达</li><li>检索策略</li></ul><hr><h3 id="_2-prompt-注入-上下文越多越好" tabindex="-1"><a class="header-anchor" href="#_2-prompt-注入-上下文越多越好"><span>2. Prompt 注入 ≠ 上下文越多越好</span></a></h3><ul><li>需要 <strong>Context Budget 管理</strong></li><li>信息冲突会直接拉低模型表现</li></ul><hr><h3 id="_3-评估困难" tabindex="-1"><a class="header-anchor" href="#_3-评估困难"><span>3. 评估困难</span></a></h3><p>RAG 的评估不是 BLEU / ROUGE，而是：</p><ul><li>Recall@K</li><li>Faithfulness（是否编造）</li><li>Groundedness（是否基于事实）</li></ul><hr><h2 id="七、rag-的常见误区" tabindex="-1"><a class="header-anchor" href="#七、rag-的常见误区"><span>七、RAG 的常见误区</span></a></h2><ol><li>❌ 把 RAG 当“外挂搜索”</li><li>❌ 认为“向量库 = 知识库”</li><li>❌ 忽视数据治理（版本、权限、生命周期）</li><li>❌ 不做引用与溯源</li></ol><hr><h2 id="八、rag-的进阶方向-2024–2026" tabindex="-1"><a class="header-anchor" href="#八、rag-的进阶方向-2024–2026"><span>八、RAG 的进阶方向（2024–2026）</span></a></h2><ol><li><p><strong>Graph RAG</strong></p><ul><li>知识图谱 + 检索</li><li>非线性关系建模（非常适合根因分析）</li></ul></li><li><p><strong>Self-RAG / Adaptive RAG</strong></p><ul><li>模型先判断“需不需要检索”</li><li>动态控制检索深度</li></ul></li><li><p><strong>RAG + Tools / MCP</strong></p><ul><li>把 RAG 作为 Tool，而不是固定流程</li></ul></li><li><p><strong>RAG + Long-Context</strong></p><ul><li>不是替代关系，而是互补</li></ul></li></ol>`,108)])])}const h=n(s,[["render",r]]),d=JSON.parse('{"path":"/posts/rag/2026-01-05-rag-01-intro.html","title":"RAG（Retrieval-Augmented Generation，检索增强生成）","lang":"zh-CN","frontmatter":{"title":"RAG（Retrieval-Augmented Generation，检索增强生成）","date":"2026-01-05T00:00:00.000Z","categories":["AI"],"tags":["ai","rag","sh"],"published":true,"description":"chat 是什么？ 下面我从**“为什么需要 RAG → RAG 是什么 → 核心架构 → 关键技术细节 → 常见模式 → 工程落地 → 典型误区与进阶方向”**几个层次，系统、完整地展开介绍 RAG（Retrieval-Augmented Generation，检索增强生成）。 会偏工程与架构视角，结合你过往关注的 知识库 / AI 平台 / 可落地...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RAG（Retrieval-Augmented Generation，检索增强生成）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T07:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/rag/2026-01-05-rag-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"RAG（Retrieval-Augmented Generation，检索增强生成）"}],["meta",{"property":"og:description","content":"chat 是什么？ 下面我从**“为什么需要 RAG → RAG 是什么 → 核心架构 → 关键技术细节 → 常见模式 → 工程落地 → 典型误区与进阶方向”**几个层次，系统、完整地展开介绍 RAG（Retrieval-Augmented Generation，检索增强生成）。 会偏工程与架构视角，结合你过往关注的 知识库 / AI 平台 / 可落地..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T07:44:04.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"rag"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T07:44:04.000Z"}]]},"git":{"createdTime":1767605962000,"updatedTime":1767771844000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":4.35,"words":1306},"filePathRelative":"posts/rag/2026-01-05-rag-01-intro.md","excerpt":"\\n<h2>是什么？</h2>\\n<p>下面我从**“为什么需要 RAG → RAG 是什么 → 核心架构 → 关键技术细节 → 常见模式 → 工程落地 → 典型误区与进阶方向”**几个层次，系统、完整地展开介绍 <strong>RAG（Retrieval-Augmented Generation，检索增强生成）</strong>。</p>\\n<p>会偏工程与架构视角，结合你过往关注的 <strong>知识库 / AI 平台 / 可落地性</strong> 来讲。</p>\\n<hr>\\n<h2>一、为什么需要 RAG（它解决的根本问题）</h2>\\n<h3>1. LLM 的三个先天限制</h3>\\n<p>即使是最强的大模型，也存在硬限制：</p>","autoDesc":true}');export{h as comp,d as data};
