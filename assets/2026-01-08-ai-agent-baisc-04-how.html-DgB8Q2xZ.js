import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as s,o as n}from"./app-DJMkg_fl.js";const t={};function l(r,a){return n(),i("div",null,[...a[0]||(a[0]=[s(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>大家好，我是老马。</p><p>我们首先来学习一下 ai-agent</p><h1 id="ai-agent" tabindex="-1"><a class="header-anchor" href="#ai-agent"><span>ai-agent</span></a></h1><h2 id="一句话先给结论" tabindex="-1"><a class="header-anchor" href="#一句话先给结论"><span>一句话先给结论</span></a></h2><blockquote><p><strong>AI Agent 本质上是一个“带反馈闭环的决策执行系统”，<br> LLM 只是其中的“策略函数”，不是系统本身。</strong></p></blockquote><hr><h2 id="一、ai-agent-的最小实现模型-核心原理" tabindex="-1"><a class="header-anchor" href="#一、ai-agent-的最小实现模型-核心原理"><span>一、AI Agent 的最小实现模型（核心原理）</span></a></h2><p>所有 Agent，无论多复杂，都可以还原成下面这个循环：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>State → Decision → Action → Observation → Evaluation → State&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>用一句工程化描述：</p><blockquote><p><strong>Agent = 状态机 + 策略函数（LLM）+ 执行器 + 评估器</strong></p></blockquote><hr><h2 id="二、从-代码层面-看-agent-的核心组件" tabindex="-1"><a class="header-anchor" href="#二、从-代码层面-看-agent-的核心组件"><span>二、从“代码层面”看 Agent 的核心组件</span></a></h2><h3 id="_1️⃣-state-状态管理" tabindex="-1"><a class="header-anchor" href="#_1️⃣-state-状态管理"><span>1️⃣ State（状态管理）</span></a></h3><p>Agent 永远不是“从零开始想”。</p><p>状态至少包括：</p><ul><li>当前目标</li><li>已完成的步骤</li><li>中间产物</li><li>上一次失败原因</li></ul><p>实现方式：</p><ul><li>内存对象</li><li>Redis / DB</li><li>文件</li><li>Context Window</li></ul><p><strong>工程原则</strong>：</p><blockquote><p>能不进 LLM 的状态，就不要进 LLM。</p></blockquote><hr><h3 id="_2️⃣-policy-reasoner-决策核心" tabindex="-1"><a class="header-anchor" href="#_2️⃣-policy-reasoner-决策核心"><span>2️⃣ Policy / Reasoner（决策核心）</span></a></h3><p>这就是 LLM 的真正角色：</p><blockquote><p><strong>给定当前状态，决定下一步“要做什么”。</strong></p></blockquote><p>典型 Prompt 结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>目标</span></span>
<span class="line"><span>当前状态</span></span>
<span class="line"><span>历史行动</span></span>
<span class="line"><span>可用工具</span></span>
<span class="line"><span>约束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出通常是：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;thought&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;action&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;tool_name&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;input&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span><span style="--shiki-light:white;--shiki-dark:#FFFFFF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是 <strong>策略函数</strong>，不是执行者。</p><hr><h3 id="_3️⃣-planner-可选但重要" tabindex="-1"><a class="header-anchor" href="#_3️⃣-planner-可选但重要"><span>3️⃣ Planner（可选但重要）</span></a></h3><p>Planner 做的是：</p><ul><li>长期任务拆解</li><li>顺序规划</li><li>优先级管理</li></ul><p>常见两种实现：</p><ol><li>Planner = LLM</li><li>Planner = 规则 + LLM 辅助</li></ol><p>很多工程系统中，<strong>Planner 与 Reasoner 是分离的</strong>。</p><hr><h3 id="_4️⃣-tool-executor-行动层" tabindex="-1"><a class="header-anchor" href="#_4️⃣-tool-executor-行动层"><span>4️⃣ Tool Executor（行动层）</span></a></h3><p>这是 Agent 真正“改变世界”的地方。</p><p>工具具备三个特征：</p><ul><li>输入明确</li><li>输出结构化</li><li>有失败语义</li></ul><p>示例：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-json"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;status&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">  &quot;reason&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;connection timeout&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>Agent 不怕失败，怕的是“不知道失败了”。</strong></p></blockquote><hr><h3 id="_5️⃣-evaluator-评估器" tabindex="-1"><a class="header-anchor" href="#_5️⃣-evaluator-评估器"><span>5️⃣ Evaluator（评估器）</span></a></h3><p>这是 Agent 能“停下来”的关键。</p><p>评估方式三类：</p><ol><li>硬规则（最推荐）</li><li>LLM Judge（次优）</li><li>人工介入</li></ol><p>工程优先级：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>规则 &gt; 程序 &gt; LLM &gt; 人</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="三、agent-loop-的真实执行流程" tabindex="-1"><a class="header-anchor" href="#三、agent-loop-的真实执行流程"><span>三、Agent Loop 的真实执行流程</span></a></h2><p>把上面拼起来，就是一个完整的 Agent Loop：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>while not done and step &lt; max_steps:</span></span>
<span class="line"><span>    state = load_state()</span></span>
<span class="line"><span>    decision = llm(state)</span></span>
<span class="line"><span>    result = execute_tool(decision)</span></span>
<span class="line"><span>    update_state(result)</span></span>
<span class="line"><span>    done = evaluate(state)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这就是全部原理，没有魔法。</strong></p><hr><h2 id="四、为什么-llm-能-当-agent-的大脑" tabindex="-1"><a class="header-anchor" href="#四、为什么-llm-能-当-agent-的大脑"><span>四、为什么 LLM 能“当 Agent 的大脑”</span></a></h2><p>因为 LLM 在这里承担的是：</p><ul><li>模式识别</li><li>策略选择</li><li>文本 → 行动映射</li></ul><p>它不是在“算最优解”，而是在：</p><blockquote><p><strong>用概率方式，选择一个“看起来最合理的下一步”。</strong></p></blockquote><p>这非常接近人类的工作方式。</p><hr><h2 id="五、常见-agent-推理范式-实现差异" tabindex="-1"><a class="header-anchor" href="#五、常见-agent-推理范式-实现差异"><span>五、常见 Agent 推理范式（实现差异）</span></a></h2><h3 id="_1️⃣-react-最常见" tabindex="-1"><a class="header-anchor" href="#_1️⃣-react-最常见"><span>1️⃣ ReAct（最常见）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Thought → Action → Observation → Thought ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>简单、可控、工程友好。</p><hr><h3 id="_2️⃣-plan-execute" tabindex="-1"><a class="header-anchor" href="#_2️⃣-plan-execute"><span>2️⃣ Plan &amp; Execute</span></a></h3><ul><li>先整体规划</li><li>再逐步执行</li><li>适合长任务</li></ul><hr><h3 id="_3️⃣-tree-graph-of-thoughts" tabindex="-1"><a class="header-anchor" href="#_3️⃣-tree-graph-of-thoughts"><span>3️⃣ Tree / Graph of Thoughts</span></a></h3><ul><li>多路径探索</li><li>成本高</li><li>适合高价值任务</li></ul><hr><h3 id="_4️⃣-fsm-dag-llm" tabindex="-1"><a class="header-anchor" href="#_4️⃣-fsm-dag-llm"><span>4️⃣ FSM / DAG + LLM</span></a></h3><ul><li>外层是确定性流程</li><li>内层由 LLM 决策</li></ul><p>这是 <strong>企业级最稳妥方案</strong>。</p><hr><h2 id="六、多-agent-的实现原理" tabindex="-1"><a class="header-anchor" href="#六、多-agent-的实现原理"><span>六、多 Agent 的实现原理</span></a></h2><p>多 Agent ≠ 多个 LLM 同时跑。</p><p>本质是：</p><blockquote><p><strong>多个策略函数 + 明确的通信协议 + 协调机制</strong></p></blockquote><p>典型模式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Manager Agent</span></span>
<span class="line"><span>   ├─ Planner Agent</span></span>
<span class="line"><span>   ├─ Executor Agent</span></span>
<span class="line"><span>   └─ Reviewer Agent</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通信方式：</p><ul><li>共享状态</li><li>消息队列</li><li>黑板模型</li></ul><hr><h2 id="七、记忆-memory-的真实实现方式" tabindex="-1"><a class="header-anchor" href="#七、记忆-memory-的真实实现方式"><span>七、记忆（Memory）的真实实现方式</span></a></h2><p>不要神秘化。</p><h3 id="常见实现" tabindex="-1"><a class="header-anchor" href="#常见实现"><span>常见实现：</span></a></h3><table><thead><tr><th>类型</th><th>实现</th></tr></thead><tbody><tr><td>短期记忆</td><td>Prompt</td></tr><tr><td>工作记忆</td><td>State</td></tr><tr><td>长期记忆</td><td>DB / Vector Store</td></tr><tr><td>经验</td><td>日志 + 总结</td></tr></tbody></table><p><strong>关键不是存，而是：什么时候读、读多少。</strong></p><hr><h2 id="八、为什么-agent-会-失控" tabindex="-1"><a class="header-anchor" href="#八、为什么-agent-会-失控"><span>八、为什么 Agent 会“失控”</span></a></h2><p>从原理上看，失控只来自 4 个原因：</p><ol><li>没有明确终止条件</li><li>工具反馈不清晰</li><li>状态不断膨胀</li><li>成本/步数无限制</li></ol><p>这都是工程问题，不是模型问题。</p><hr><h2 id="九、企业级-agent-的关键设计原则" tabindex="-1"><a class="header-anchor" href="#九、企业级-agent-的关键设计原则"><span>九、企业级 Agent 的关键设计原则</span></a></h2><p>这是很多 Demo 到不了生产的原因。</p><h3 id="必须具备" tabindex="-1"><a class="header-anchor" href="#必须具备"><span>必须具备：</span></a></h3><ul><li>权限隔离</li><li>行为白名单</li><li>成本上限</li><li>审计日志</li><li>人工审批点</li></ul><hr><h2 id="十、一句工程总结" tabindex="-1"><a class="header-anchor" href="#十、一句工程总结"><span>十、一句工程总结</span></a></h2><blockquote><p><strong>AI Agent ≠ 聪明程序<br> AI Agent = 可治理的自治系统</strong></p></blockquote><p>理解了这个实现原理，你就会发现：</p><ul><li>Agent 并不神秘</li><li>难点不在模型</li><li>难点在系统设计</li></ul><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,111)])])}const d=e(t,[["render",l]]),o=JSON.parse(`{"path":"/posts/agent/2026-01-08-ai-agent-baisc-04-how.html","title":"ai-agent 的实现原理？","lang":"zh-CN","frontmatter":{"title":"ai-agent 的实现原理？","date":"2026-01-08T00:00:00.000Z","categories":["AI-AGENT"],"tags":["ai","ai-agent","sh"],"published":true,"description":"前言 大家好，我是老马。 我们首先来学习一下 ai-agent ai-agent 一句话先给结论 AI Agent 本质上是一个“带反馈闭环的决策执行系统”， LLM 只是其中的“策略函数”，不是系统本身。 一、AI Agent 的最小实现模型（核心原理） 所有 Agent，无论多复杂，都可以还原成下面这个循环： 用一句工程化描述： Agent = 状...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ai-agent 的实现原理？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-08T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-08T04:05:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/agent/2026-01-08-ai-agent-baisc-04-how.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"ai-agent 的实现原理？"}],["meta",{"property":"og:description","content":"前言 大家好，我是老马。 我们首先来学习一下 ai-agent ai-agent 一句话先给结论 AI Agent 本质上是一个“带反馈闭环的决策执行系统”， LLM 只是其中的“策略函数”，不是系统本身。 一、AI Agent 的最小实现模型（核心原理） 所有 Agent，无论多复杂，都可以还原成下面这个循环： 用一句工程化描述： Agent = 状..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-08T04:05:33.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"ai-agent"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-08T04:05:33.000Z"}]]},"git":{"createdTime":1767845133000,"updatedTime":1767845133000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":1}]},"readingTime":{"minutes":3.38,"words":1015},"filePathRelative":"posts/agent/2026-01-08-ai-agent-baisc-04-how.md","excerpt":"<h2>前言</h2>\\n<p>大家好，我是老马。</p>\\n<p>我们首先来学习一下 ai-agent</p>\\n<h1>ai-agent</h1>\\n<h2>一句话先给结论</h2>\\n<blockquote>\\n<p><strong>AI Agent 本质上是一个“带反馈闭环的决策执行系统”，<br>\\nLLM 只是其中的“策略函数”，不是系统本身。</strong></p>\\n</blockquote>\\n<hr>\\n<h2>一、AI Agent 的最小实现模型（核心原理）</h2>\\n<p>所有 Agent，无论多复杂，都可以还原成下面这个循环：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-\\"><span class=\\"line\\"><span>State → Decision → Action → Observation → Evaluation → State'</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{d as comp,o as data};
