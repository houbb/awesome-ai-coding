import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o as e}from"./app-DJMkg_fl.js";const t={};function l(r,a){return e(),n("div",null,[...a[0]||(a[0]=[i(`<h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="ast-abstract-syntax-tree-抽象语法树" tabindex="-1"><a class="header-anchor" href="#ast-abstract-syntax-tree-抽象语法树"><span>AST（Abstract Syntax Tree，抽象语法树）</span></a></h2><h1 id="一、ast-是什么-精准定义" tabindex="-1"><a class="header-anchor" href="#一、ast-是什么-精准定义"><span>一、AST 是什么（精准定义）</span></a></h1><p><strong>Abstract Syntax Tree（AST）</strong> 是：</p><blockquote><p><strong>在语法分析之后，对程序“语义结构”的抽象树形表示，刻意丢弃与语义无关的语法细节，只保留“程序在做什么”。</strong></p></blockquote><p>强调三点：</p><ol><li><strong>Abstract（抽象）</strong><br> 去掉括号、分号、关键字冗余、语法糖</li><li><strong>Syntax（语法）</strong><br> 仍然是结构化的、可推理的代码结构</li><li><strong>Tree（树）</strong><br> 层级明确，天然适合递归、遍历、分析</li></ol><p>一句工程化理解：</p><blockquote><p><strong>AST 是“编译器、静态分析、IDE、AI”共同认可的最小语义结构单元。</strong></p></blockquote><hr><h1 id="二、ast-从哪里来-在编译流程中的位置" tabindex="-1"><a class="header-anchor" href="#二、ast-从哪里来-在编译流程中的位置"><span>二、AST 从哪里来？（在编译流程中的位置）</span></a></h1><p>在经典编译流程中：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Source Code</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Lexer（Token）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Parser（CST / Parse Tree）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>AST   ←—— 我们现在讨论的核心</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Semantic Analysis</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>IR / Optimization / CodeGen</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AST <strong>不是 Parser 的天然产物</strong>，而是：</p><ul><li>从 CST 中 <strong>重写 / 折叠 / 规约</strong> 得到</li><li>或 Parser 在构建时“直接生成语义节点”</li></ul><hr><h1 id="三、ast-与-cst-的根本区别-再次但更深一层" tabindex="-1"><a class="header-anchor" href="#三、ast-与-cst-的根本区别-再次但更深一层"><span>三、AST 与 CST 的根本区别（再次但更深一层）</span></a></h1><blockquote><p>你前面问过：<strong>“AI 都能理解自然语言了，为什么还要语法树？”</strong><br> AST 就是这个问题的“中间答案”。</p></blockquote><h3 id="对比表-工程视角" tabindex="-1"><a class="header-anchor" href="#对比表-工程视角"><span>对比表（工程视角）</span></a></h3><table><thead><tr><th>维度</th><th>CST</th><th>AST</th></tr></thead><tbody><tr><td>关注点</td><td>语法形式</td><td>程序语义</td></tr><tr><td>是否保留括号/分号</td><td>是</td><td>否</td></tr><tr><td>是否保留注释</td><td>通常是</td><td>否</td></tr><tr><td>是否依赖 Grammar</td><td>强</td><td>弱</td></tr><tr><td>是否稳定</td><td>易变</td><td>稳定</td></tr><tr><td>是否适合语义分析</td><td>否</td><td>是</td></tr><tr><td>是否适合 AI 推理</td><td>一般</td><td>非常适合</td></tr></tbody></table><hr><h3 id="一个极直观的例子" tabindex="-1"><a class="header-anchor" href="#一个极直观的例子"><span>一个极直观的例子</span></a></h3><p>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ((a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> c </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    foo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>CST（简化）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>ifStatement</span></span>
<span class="line"><span> ├─ &#39;if&#39;</span></span>
<span class="line"><span> ├─ &#39;(&#39;</span></span>
<span class="line"><span> ├─ expression</span></span>
<span class="line"><span> │   ├─ &#39;(&#39;</span></span>
<span class="line"><span> │   ├─ expression</span></span>
<span class="line"><span> │   │   ├─ identifier(a)</span></span>
<span class="line"><span> │   │   ├─ &#39;+&#39;</span></span>
<span class="line"><span> │   │   └─ identifier(b)</span></span>
<span class="line"><span> │   ├─ &#39;)&#39;</span></span>
<span class="line"><span> │   ├─ &#39;*&#39;</span></span>
<span class="line"><span> │   └─ identifier(c)</span></span>
<span class="line"><span> ├─ &#39;)&#39;</span></span>
<span class="line"><span> ├─ &#39;&gt;&#39;</span></span>
<span class="line"><span> ├─ literal(10)</span></span>
<span class="line"><span> └─ block</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>AST（简化）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>If</span></span>
<span class="line"><span> ├─ Condition: GreaterThan</span></span>
<span class="line"><span> │    ├─ Multiply</span></span>
<span class="line"><span> │    │    ├─ Add(a, b)</span></span>
<span class="line"><span> │    │    └─ c</span></span>
<span class="line"><span> │    └─ 10</span></span>
<span class="line"><span> └─ Then: Block(foo())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>关键差异</strong>：<br> AST <strong>不再描述“括号在哪”</strong>，而是描述 <strong>“运算关系是什么”</strong>。</p><hr><h1 id="四、ast-的核心结构设计" tabindex="-1"><a class="header-anchor" href="#四、ast-的核心结构设计"><span>四、AST 的核心结构设计</span></a></h1><h3 id="_1️⃣-ast-节点的典型分类" tabindex="-1"><a class="header-anchor" href="#_1️⃣-ast-节点的典型分类"><span>1️⃣ AST 节点的典型分类</span></a></h3><p>几乎所有语言的 AST，都可以归纳为几类：</p><h4 id="声明类-declaration" tabindex="-1"><a class="header-anchor" href="#声明类-declaration"><span>声明类（Declaration）</span></a></h4><ul><li>Program</li><li>Package / Module</li><li>Class / Interface</li><li>Function / Method</li><li>VariableDeclaration</li></ul><h4 id="语句类-statement" tabindex="-1"><a class="header-anchor" href="#语句类-statement"><span>语句类（Statement）</span></a></h4><ul><li>If</li><li>For / While</li><li>Return</li><li>Block</li><li>Try / Catch</li></ul><h4 id="表达式类-expression" tabindex="-1"><a class="header-anchor" href="#表达式类-expression"><span>表达式类（Expression）</span></a></h4><ul><li>BinaryExpression</li><li>UnaryExpression</li><li>CallExpression</li><li>Assignment</li><li>Literal</li><li>Identifier</li></ul><hr><h3 id="_2️⃣-ast-是-语义层级-的树" tabindex="-1"><a class="header-anchor" href="#_2️⃣-ast-是-语义层级-的树"><span>2️⃣ AST 是“语义层级”的树</span></a></h3><p>重要理解：</p><blockquote><p><strong>AST 的父子关系 = 语义包含关系</strong></p></blockquote><p>例如：</p><ul><li><code>If</code> 节点 <strong>拥有</strong> <code>Condition</code></li><li><code>Function</code> 节点 <strong>拥有</strong> <code>Parameters + Body</code></li><li><code>CallExpression</code> 节点 <strong>拥有</strong> <code>Callee + Arguments</code></li></ul><p>这对：</p><ul><li>编译器</li><li>静态分析</li><li>AI 结构理解<br> 都极其关键。</li></ul><hr><h1 id="五、ast-构建的核心技术" tabindex="-1"><a class="header-anchor" href="#五、ast-构建的核心技术"><span>五、AST 构建的核心技术</span></a></h1><h3 id="_1️⃣-两种主流方式" tabindex="-1"><a class="header-anchor" href="#_1️⃣-两种主流方式"><span>1️⃣ 两种主流方式</span></a></h3><h4 id="方式一-cst-→-ast-重写-经典" tabindex="-1"><a class="header-anchor" href="#方式一-cst-→-ast-重写-经典"><span>方式一：CST → AST 重写（经典）</span></a></h4><ul><li>Parser 生成 CST</li><li>Visitor / Transformer 构建 AST</li><li>ANTLR、javac 常用</li></ul><p>优点：</p><ul><li>语法清晰</li><li>可控性强</li></ul><p>缺点：</p><ul><li>实现复杂</li><li>有性能成本</li></ul><hr><h4 id="方式二-parser-直接构建-ast-工业常用" tabindex="-1"><a class="header-anchor" href="#方式二-parser-直接构建-ast-工业常用"><span>方式二：Parser 直接构建 AST（工业常用）</span></a></h4><ul><li>递归下降 parser</li><li>每个产生式返回 AST 节点</li></ul><p>优点：</p><ul><li>高效</li><li>AST 天然干净</li></ul><p>缺点：</p><ul><li>Grammar 与 AST 强耦合</li></ul><hr><h3 id="_2️⃣-典型技术点" tabindex="-1"><a class="header-anchor" href="#_2️⃣-典型技术点"><span>2️⃣ 典型技术点</span></a></h3><ul><li>Visitor Pattern</li><li>Pattern Matching（Rust / Scala）</li><li>AST Node Interning</li><li>Source Range（AST 节点 → 源码位置）</li></ul><hr><h1 id="六、ast-在-语义分析-中的核心地位" tabindex="-1"><a class="header-anchor" href="#六、ast-在-语义分析-中的核心地位"><span>六、AST 在“语义分析”中的核心地位</span></a></h1><blockquote><p><strong>没有 AST，就谈不上真正的编译器</strong></p></blockquote><h3 id="ast-语义分析能做什么" tabindex="-1"><a class="header-anchor" href="#ast-语义分析能做什么"><span>AST + 语义分析能做什么？</span></a></h3><ul><li>变量解析（Name Resolution）</li><li>类型检查</li><li>重载 / 泛型 / trait 解析</li><li>控制流构建（CFG）</li><li>数据流分析</li></ul><p>在这个阶段，AST 通常会被：</p><ul><li><strong>Annotate（打标签）</strong></li><li>变成 <strong>Typed AST</strong></li></ul><hr><h1 id="七、ast-在现代工程中的真实用途" tabindex="-1"><a class="header-anchor" href="#七、ast-在现代工程中的真实用途"><span>七、AST 在现代工程中的真实用途</span></a></h1><h3 id="_1️⃣-编译器-语言实现" tabindex="-1"><a class="header-anchor" href="#_1️⃣-编译器-语言实现"><span>1️⃣ 编译器 &amp; 语言实现</span></a></h3><ul><li>javac</li><li>clang</li><li>rustc</li></ul><hr><h3 id="_2️⃣-ide-静态分析" tabindex="-1"><a class="header-anchor" href="#_2️⃣-ide-静态分析"><span>2️⃣ IDE &amp; 静态分析</span></a></h3><ul><li>跳转定义</li><li>重构</li><li>Lint</li><li>Dead code 检测</li></ul><hr><h3 id="_3️⃣-code-graph-程序分析" tabindex="-1"><a class="header-anchor" href="#_3️⃣-code-graph-程序分析"><span>3️⃣ Code Graph / 程序分析</span></a></h3><p>AST 是构建以下结构的输入：</p><ul><li>Call Graph</li><li>CFG</li><li>Data Flow Graph</li><li>Dependency Graph</li></ul><hr><h3 id="_4️⃣-ai-llm-rag-你正在深入的方向" tabindex="-1"><a class="header-anchor" href="#_4️⃣-ai-llm-rag-你正在深入的方向"><span>4️⃣ AI / LLM / RAG（你正在深入的方向）</span></a></h3><p>AST 在 AI 编程中的作用非常现实：</p><ul><li>结构化切分（Chunking）</li><li>稳定引用（Symbol-level grounding）</li><li>减少 prompt 噪音</li><li>支撑可解释生成</li></ul><blockquote><p><strong>AST 是“AI 理解代码”的结构锚点</strong></p></blockquote><hr><h1 id="八、ast-的局限性-非常重要" tabindex="-1"><a class="header-anchor" href="#八、ast-的局限性-非常重要"><span>八、AST 的局限性（非常重要）</span></a></h1><h3 id="_1️⃣-ast-程序行为" tabindex="-1"><a class="header-anchor" href="#_1️⃣-ast-程序行为"><span>1️⃣ AST ≠ 程序行为</span></a></h3><p>AST <strong>不知道</strong>：</p><ul><li>实际执行路径</li><li>运行时值</li><li>并发行为</li></ul><hr><h3 id="_2️⃣-ast-不适合直接做优化" tabindex="-1"><a class="header-anchor" href="#_2️⃣-ast-不适合直接做优化"><span>2️⃣ AST 不适合直接做优化</span></a></h3><ul><li>优化依赖 CFG / SSA / IR</li><li>AST 更偏“结构理解”</li></ul><hr><h3 id="_3️⃣-ast-不是跨语言通用结构" tabindex="-1"><a class="header-anchor" href="#_3️⃣-ast-不是跨语言通用结构"><span>3️⃣ AST 不是跨语言通用结构</span></a></h3><ul><li>Java AST ≠ Python AST</li><li>只能在“同一语言域”内使用</li></ul><hr><h1 id="九、ast-cst-ir-的一句话对照" tabindex="-1"><a class="header-anchor" href="#九、ast-cst-ir-的一句话对照"><span>九、AST / CST / IR 的一句话对照</span></a></h1><blockquote><p><strong>CST：代码“长什么样”<br> AST：代码“是什么意思”<br> IR：代码“怎么执行”</strong></p></blockquote><hr><h1 id="十、站在你这个层级的总结" tabindex="-1"><a class="header-anchor" href="#十、站在你这个层级的总结"><span>十、站在你这个层级的总结</span></a></h1><p>结合你当前对：</p><ul><li>编译器前端</li><li>Code Graph</li><li>RAG</li><li>AI 平台</li></ul><p>的整体思考，我给你一个“工程结论级”的总结：</p><blockquote><p><strong>AST 是“人类语言 → 机器语义”的关键桥梁。<br> 没有 AST，AI 只能‘读代码文本’，有了 AST，AI 才是在‘理解程序结构’。</strong></p></blockquote><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/tree-sitter/tree-sitter" target="_blank" rel="noopener noreferrer">https://github.com/tree-sitter/tree-sitter</a></p>`,111)])])}const h=s(t,[["render",l]]),o=JSON.parse('{"path":"/posts/code-graph/2026-01-05-source-code-to-zero-03-ast-intro.html","title":"AST（Abstract Syntax Tree，抽象语法树）","lang":"zh-CN","frontmatter":{"title":"AST（Abstract Syntax Tree，抽象语法树）","date":"2026-01-05T00:00:00.000Z","categories":["AI"],"tags":["ai","ai-coding","code-graph","sh"],"published":true,"description":"chat AST（Abstract Syntax Tree，抽象语法树） 一、AST 是什么（精准定义） Abstract Syntax Tree（AST） 是： 在语法分析之后，对程序“语义结构”的抽象树形表示，刻意丢弃与语义无关的语法细节，只保留“程序在做什么”。 强调三点： Abstract（抽象） 去掉括号、分号、关键字冗余、语法糖 Synta...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AST（Abstract Syntax Tree，抽象语法树）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T07:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/code-graph/2026-01-05-source-code-to-zero-03-ast-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"AST（Abstract Syntax Tree，抽象语法树）"}],["meta",{"property":"og:description","content":"chat AST（Abstract Syntax Tree，抽象语法树） 一、AST 是什么（精准定义） Abstract Syntax Tree（AST） 是： 在语法分析之后，对程序“语义结构”的抽象树形表示，刻意丢弃与语义无关的语法细节，只保留“程序在做什么”。 强调三点： Abstract（抽象） 去掉括号、分号、关键字冗余、语法糖 Synta..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T07:44:04.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"code-graph"}],["meta",{"property":"article:tag","content":"ai-coding"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T07:44:04.000Z"}]]},"git":{"createdTime":1767605962000,"updatedTime":1767771844000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":3.9,"words":1170},"filePathRelative":"posts/code-graph/2026-01-05-source-code-to-zero-03-ast-intro.md","excerpt":"\\n<h2>AST（Abstract Syntax Tree，抽象语法树）</h2>\\n<h1>一、AST 是什么（精准定义）</h1>\\n<p><strong>Abstract Syntax Tree（AST）</strong> 是：</p>\\n<blockquote>\\n<p><strong>在语法分析之后，对程序“语义结构”的抽象树形表示，刻意丢弃与语义无关的语法细节，只保留“程序在做什么”。</strong></p>\\n</blockquote>\\n<p>强调三点：</p>\\n<ol>\\n<li><strong>Abstract（抽象）</strong><br>\\n去掉括号、分号、关键字冗余、语法糖</li>\\n<li><strong>Syntax（语法）</strong><br>\\n仍然是结构化的、可推理的代码结构</li>\\n<li><strong>Tree（树）</strong><br>\\n层级明确，天然适合递归、遍历、分析</li>\\n</ol>","autoDesc":true}');export{h as comp,o as data};
