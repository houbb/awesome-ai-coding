import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-CoVRO5bg.js";const l={};function t(r,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="ai-编程如何降低研发编写的压力-提升文档编写的压力-比如把公共的常见的方式-直接放在公共部分-而不是每次都要重新写" tabindex="-1"><a class="header-anchor" href="#ai-编程如何降低研发编写的压力-提升文档编写的压力-比如把公共的常见的方式-直接放在公共部分-而不是每次都要重新写"><span>AI 编程如何降低研发编写的压力，提升文档编写的压力？比如把公共的常见的方式，直接放在公共部分，而不是每次都要重新写</span></a></h1><p>这是一个<strong>典型的“结构性转移工作量”的问题</strong>：<br> 不是让 AI 替你多写代码，而是<strong>把重复、低价值、易标准化的“研发负担”前移并固化为“文档资产”</strong>，从而把压力从“每次写”转移为“一次建、长期用”。</p><p>下面我从<strong>原则 → 架构 → 具体落地机制 → 示例</strong>四个层次，系统回答你的问题。</p><hr><h2 id="一、核心原则-把-隐性约定-变成-显性公共文档" tabindex="-1"><a class="header-anchor" href="#一、核心原则-把-隐性约定-变成-显性公共文档"><span>一、核心原则：把“隐性约定”变成“显性公共文档”</span></a></h2><p>传统研发的真实负担主要来自三类事情：</p><ol><li><strong>重复说明“我们一贯是怎么做的”</strong></li><li><strong>解释“这个项目的默认假设”</strong></li><li><strong>为 AI / 新人 / 跨团队反复补上下文</strong></li></ol><p>AI 编程时代的关键转变是：</p><blockquote><p><strong>不再每个需求都解释“怎么做”，<br> 而是声明“除非特别说明，一律按公共规则做”。</strong></p></blockquote><p>这本质上是：</p><ul><li>从「<strong>逐需求说明</strong>」<br> → 到「<strong>基线规则 + 差异声明</strong>」</li></ul><hr><h2 id="二、总体架构-三层文档-把压力从-人脑-迁移到-结构" tabindex="-1"><a class="header-anchor" href="#二、总体架构-三层文档-把压力从-人脑-迁移到-结构"><span>二、总体架构：三层文档，把压力从“人脑”迁移到“结构”</span></a></h2><p>我建议你用一个<strong>强约束、可被 AI 执行的文档分层结构</strong>：</p><h3 id="_1️⃣-公共基线层-once-for-all" tabindex="-1"><a class="header-anchor" href="#_1️⃣-公共基线层-once-for-all"><span>1️⃣ 公共基线层（Once, for All）</span></a></h3><blockquote><p><strong>一次写好，所有项目复用</strong></p></blockquote><p><strong>放什么？</strong></p><ul><li>通用技术选型约定</li><li>通用实现模式</li><li>默认行为</li><li>常见异常处理</li><li>日志、监控、错误码规范</li><li>命名、目录、分层、DTO / VO 约定</li></ul><p><strong>典型文件：</strong></p><ul><li><code>ENGINEERING_BASELINE.md</code></li><li><code>COMMON_PATTERNS.md</code></li><li><code>DEFAULT_BEHAVIORS.md</code></li></ul><blockquote><p>这是**“研发不需要再写的部分”**</p></blockquote><hr><h3 id="_2️⃣-项目约束层-project-profile" tabindex="-1"><a class="header-anchor" href="#_2️⃣-项目约束层-project-profile"><span>2️⃣ 项目约束层（Project Profile）</span></a></h3><blockquote><p><strong>声明：这个项目和公共基线有什么不同</strong></p></blockquote><p><strong>放什么？</strong></p><ul><li>项目背景</li><li>技术栈偏差</li><li>特殊约束（性能、安全、合规）</li><li>不适用的公共规则</li></ul><p><strong>典型文件：</strong></p><ul><li><code>PROJECT_PROFILE.md</code></li></ul><blockquote><p>这是**“只写差异，不写常规”**</p></blockquote><hr><h3 id="_3️⃣-需求执行层-design-task" tabindex="-1"><a class="header-anchor" href="#_3️⃣-需求执行层-design-task"><span>3️⃣ 需求执行层（Design / Task）</span></a></h3><blockquote><p><strong>只描述“变化”与“新增”</strong></p></blockquote><p><strong>放什么？</strong></p><ul><li>新功能逻辑</li><li>特殊分支</li><li>与公共模式的偏离点</li><li>必须覆盖的边界</li></ul><p><strong>典型文件：</strong></p><ul><li><code>DESIGN.md</code></li><li><code>TASK.md</code></li></ul><blockquote><p>这是<strong>研发真正需要动脑的部分</strong></p></blockquote><hr><h2 id="三、关键机制-用-ai-把-默认-变成-无需再写" tabindex="-1"><a class="header-anchor" href="#三、关键机制-用-ai-把-默认-变成-无需再写"><span>三、关键机制：用 AI 把“默认”变成“无需再写”</span></a></h2><p>下面是<strong>真正能“降研发压力、提文档质量”的机制设计</strong>。</p><hr><h3 id="机制-1-公共模式-ai-的-隐式上下文" tabindex="-1"><a class="header-anchor" href="#机制-1-公共模式-ai-的-隐式上下文"><span>机制 1：公共模式 = AI 的“隐式上下文”</span></a></h3><p>你不再要求研发每次写：</p><blockquote><ul><li>Controller 如何写</li><li>Service 是否幂等</li><li>异常如何抛</li><li>日志打几层</li></ul></blockquote><p>而是在 <code>COMMON_PATTERNS.md</code> 中声明：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## 通用接口实现模式</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Controller 仅负责参数校验与返回包装</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Service 必须保证幂等</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 所有业务异常使用 BizException</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 所有异常必须记录 error 日志</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 成功路径使用 info 日志</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 <strong>AI 提示词中明确</strong>：</p><blockquote><p>“除非 <a href="http://DESIGN.md" target="_blank" rel="noopener noreferrer">DESIGN.md</a> 明确声明例外，否则一律遵循 COMMON_PATTERNS.md”</p></blockquote><p><strong>效果：</strong></p><ul><li>研发不用再写</li><li>AI 也不会发散</li><li>审查点变少</li></ul><hr><h3 id="机制-2-文档-缺省即采用-而不是-每次重写" tabindex="-1"><a class="header-anchor" href="#机制-2-文档-缺省即采用-而不是-每次重写"><span>机制 2：文档“缺省即采用”，而不是“每次重写”</span></a></h3><p>强制一个规则：</p><blockquote><p><strong>如果文档没有写，代表使用默认公共方案</strong></p></blockquote><p>而不是：</p><ul><li>没写 = 不清楚</li><li>没写 = 要问</li></ul><p>这会倒逼：</p><ul><li>公共文档写清楚</li><li>项目文档极度简化</li></ul><hr><h3 id="机制-3-用-否定式文档-代替-重复式文档" tabindex="-1"><a class="header-anchor" href="#机制-3-用-否定式文档-代替-重复式文档"><span>机制 3：用“否定式文档”代替“重复式文档”</span></a></h3><p>研发最痛苦的不是写“怎么做”，而是写**“和以前一样”**。</p><p>你可以要求：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## 本需求与公共规范的差异</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 不使用默认的分页查询方式（原因：XXX）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 不使用标准错误码（原因：XXX）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而不是：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## 实现方式</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 使用标准分页</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 使用标准错误码</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>负担下降 50%+</strong></p><hr><h3 id="机制-4-公共文档-ai-的-编译期依赖" tabindex="-1"><a class="header-anchor" href="#机制-4-公共文档-ai-的-编译期依赖"><span>机制 4：公共文档 = AI 的“编译期依赖”</span></a></h3><p>你可以明确告诉 AI：</p><blockquote><p>“公共文档视为不可修改的系统依赖，<br> 如发现缺失，请提出修改建议，不得私自发明实现。”</p></blockquote><p>这会产生两个好处：</p><ol><li>AI 不再“临时发挥”</li><li>公共文档反而持续被完善（像代码库一样演进）</li></ol><hr><h2 id="四、一个完整示例-研发压力对比" tabindex="-1"><a class="header-anchor" href="#四、一个完整示例-研发压力对比"><span>四、一个完整示例（研发压力对比）</span></a></h2><h3 id="❌-传统写法-研发累" tabindex="-1"><a class="header-anchor" href="#❌-传统写法-研发累"><span>❌ 传统写法（研发累）</span></a></h3><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## 接口说明</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 使用 Spring MVC</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 参数校验使用 @Valid</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 异常统一返回 Result</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 日志打印请求参数和响应</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="✅-ai-友好-低负担写法" tabindex="-1"><a class="header-anchor" href="#✅-ai-友好-低负担写法"><span>✅ AI 友好 + 低负担写法</span></a></h3><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">## 实现说明</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 接口实现遵循公共接口规范</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 本接口的特殊点：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 需要额外校验 xxx 字段</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 异常需要额外记录 traceId</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>前提：</strong></p><ul><li>公共接口规范已经在 <code>COMMON_PATTERNS.md</code> 写清楚</li></ul><hr><h2 id="五、最终总结一句话" tabindex="-1"><a class="header-anchor" href="#五、最终总结一句话"><span>五、最终总结一句话</span></a></h2><blockquote><p><strong>AI 编程时代，<br> 不是让研发写更多文档，<br> 而是把“重复说明”变成“可复用规则”，<br> 把“经验负担”升级为“公共资产”。</strong></p></blockquote><p>如果你愿意，下一步我可以帮你直接：</p><ul><li>设计一套 <strong>“公共工程规范文档模板（AI 可执行版）”</strong></li><li>或把你现有的项目文档，<strong>重构成“公共基线 + 差异声明”结构</strong></li></ul><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,87)])])}const d=i(l,[["render",t]]),o=JSON.parse('{"path":"/posts/sdd/2025-11-20-ai-sdd-34-once-for-all.html","title":"AI SDD 开发规范-34-降低编写压力","lang":"zh-CN","frontmatter":{"title":"AI SDD 开发规范-34-降低编写压力","tags":["ai","sdd","sh"],"published":true,"description":"AI 编程如何降低研发编写的压力，提升文档编写的压力？比如把公共的常见的方式，直接放在公共部分，而不是每次都要重新写 这是一个典型的“结构性转移工作量”的问题： 不是让 AI 替你多写代码，而是把重复、低价值、易标准化的“研发负担”前移并固化为“文档资产”，从而把压力从“每次写”转移为“一次建、长期用”。 下面我从原则 → 架构 → 具体落地机制 → ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AI SDD 开发规范-34-降低编写压力\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-27T07:18:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/sdd/2025-11-20-ai-sdd-34-once-for-all.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"AI SDD 开发规范-34-降低编写压力"}],["meta",{"property":"og:description","content":"AI 编程如何降低研发编写的压力，提升文档编写的压力？比如把公共的常见的方式，直接放在公共部分，而不是每次都要重新写 这是一个典型的“结构性转移工作量”的问题： 不是让 AI 替你多写代码，而是把重复、低价值、易标准化的“研发负担”前移并固化为“文档资产”，从而把压力从“每次写”转移为“一次建、长期用”。 下面我从原则 → 架构 → 具体落地机制 → ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-27T07:18:50.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"sdd"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:modified_time","content":"2025-12-27T07:18:50.000Z"}]]},"git":{"createdTime":1766819930000,"updatedTime":1766819930000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":4.2,"words":1259},"filePathRelative":"posts/sdd/2025-11-20-ai-sdd-34-once-for-all.md","excerpt":"\\n<p>这是一个<strong>典型的“结构性转移工作量”的问题</strong>：<br>\\n不是让 AI 替你多写代码，而是<strong>把重复、低价值、易标准化的“研发负担”前移并固化为“文档资产”</strong>，从而把压力从“每次写”转移为“一次建、长期用”。</p>\\n<p>下面我从<strong>原则 → 架构 → 具体落地机制 → 示例</strong>四个层次，系统回答你的问题。</p>\\n<hr>\\n<h2>一、核心原则：把“隐性约定”变成“显性公共文档”</h2>\\n<p>传统研发的真实负担主要来自三类事情：</p>\\n<ol>\\n<li><strong>重复说明“我们一贯是怎么做的”</strong></li>\\n<li><strong>解释“这个项目的默认假设”</strong></li>\\n<li><strong>为 AI / 新人 / 跨团队反复补上下文</strong></li>\\n</ol>","autoDesc":true}');export{d as comp,o as data};
