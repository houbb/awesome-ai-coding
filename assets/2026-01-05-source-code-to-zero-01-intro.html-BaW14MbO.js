import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as i}from"./app-BCq4GIDA.js";const l={};function r(t,a){return i(),n("div",null,[...a[0]||(a[0]=[e(`<h1 id="源码-》字节码" tabindex="-1"><a class="header-anchor" href="#源码-》字节码"><span>源码===》字节码</span></a></h1><p>下面我会按**“从工程现实出发、同时不失编译原理严谨性”<strong>的方式，把</strong>经典语言编译从源代码到 0/1 的完整路径<strong>系统拆开，并明确每一阶段的</strong>输入 / 输出 / 关键技术 / 现实中的实现形态**。</p><p>我会刻意区分三条线索：</p><ol><li><strong>经典编译理论中的标准流水线</strong></li><li><strong>现代工业级编译器的真实形态</strong></li><li><strong>你当前关心的 AI / 代码理解 / RAG 体系中，这些阶段各自的价值</strong></li></ol><hr><h1 id="一、整体鸟瞰-从源代码到-0-和-1" tabindex="-1"><a class="header-anchor" href="#一、整体鸟瞰-从源代码到-0-和-1"><span>一、整体鸟瞰：从源代码到 0 和 1</span></a></h1><p>先给你一张“压缩版”的总览图：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Source Code</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>1. 词法分析（Lexical Analysis）</span></span>
<span class="line"><span>  ↓ Tokens</span></span>
<span class="line"><span>2. 语法分析（Syntax Analysis）</span></span>
<span class="line"><span>  ↓ CST / Parse Tree</span></span>
<span class="line"><span>3. 抽象语法树（AST）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>4. 语义分析（Semantic Analysis）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>5. 中间表示（IR）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>6. 优化（Optimization）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>7. 目标代码生成（Code Generation）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>8. 汇编（Assembler）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>9. 链接（Linker）</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Machine Code（0 和 1）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这条链路在**C / C++ / Rust / Go / Java（AOT）**中基本成立。</p><hr><h1 id="二、逐阶段拆解-从源码开始" tabindex="-1"><a class="header-anchor" href="#二、逐阶段拆解-从源码开始"><span>二、逐阶段拆解（从源码开始）</span></a></h1><p>下面我按<strong>每一步：做什么 / 核心技术 / 产物 / 工程中的代表实现</strong>来讲。</p><hr><h2 id="_1️⃣-词法分析-lexical-analysis-lexer" tabindex="-1"><a class="header-anchor" href="#_1️⃣-词法分析-lexical-analysis-lexer"><span>1️⃣ 词法分析（Lexical Analysis / Lexer）</span></a></h2><h3 id="做什么" tabindex="-1"><a class="header-anchor" href="#做什么"><span>做什么</span></a></h3><p>把<strong>字符流</strong>变成<strong>有意义的最小单元（Token）</strong>。</p><p>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>变成：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>KEYWORD(int)</span></span>
<span class="line"><span>IDENTIFIER(a)</span></span>
<span class="line"><span>OPERATOR(=)</span></span>
<span class="line"><span>IDENTIFIER(b)</span></span>
<span class="line"><span>OPERATOR(+)</span></span>
<span class="line"><span>INTEGER_LITERAL(1)</span></span>
<span class="line"><span>SEMICOLON</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="核心技术" tabindex="-1"><a class="header-anchor" href="#核心技术"><span>核心技术</span></a></h3><ul><li>正则表达式</li><li>有限自动机（DFA / NFA）</li><li>最长匹配原则（Maximal Munch）</li></ul><hr><h3 id="工程实现" tabindex="-1"><a class="header-anchor" href="#工程实现"><span>工程实现</span></a></h3><ul><li>Lex / Flex</li><li>ANTLR Lexer</li><li>Tree-sitter lexer（内嵌）</li></ul><hr><h3 id="现实意义" tabindex="-1"><a class="header-anchor" href="#现实意义"><span>现实意义</span></a></h3><ul><li><strong>性能极高</strong></li><li>错误恢复能力弱</li><li>是后续一切结构的“入口”</li></ul><hr><h2 id="_2️⃣-语法分析-syntax-analysis-parser" tabindex="-1"><a class="header-anchor" href="#_2️⃣-语法分析-syntax-analysis-parser"><span>2️⃣ 语法分析（Syntax Analysis / Parser）</span></a></h2><h3 id="做什么-1" tabindex="-1"><a class="header-anchor" href="#做什么-1"><span>做什么</span></a></h3><p>把 Token 按语法规则组织成树。</p><hr><h3 id="产物" tabindex="-1"><a class="header-anchor" href="#产物"><span>产物</span></a></h3><ul><li><strong>CST（Concrete Syntax Tree）</strong></li><li>或 Parse Tree</li></ul><hr><h3 id="核心技术-1" tabindex="-1"><a class="header-anchor" href="#核心技术-1"><span>核心技术</span></a></h3><ul><li>上下文无关文法（CFG）</li><li>LL / LR / LALR / GLR / PEG</li><li>递归下降</li><li>冲突消解（shift/reduce）</li></ul><hr><h3 id="工程实现-1" tabindex="-1"><a class="header-anchor" href="#工程实现-1"><span>工程实现</span></a></h3><ul><li>ANTLR（LL(*)）</li><li>Bison（LALR）</li><li>Tree-sitter（GLR + 增量）</li></ul><hr><h3 id="现实意义-1" tabindex="-1"><a class="header-anchor" href="#现实意义-1"><span>现实意义</span></a></h3><ul><li>决定语言“长什么样”</li><li>IDE / 格式化 / refactor 的基础</li></ul><hr><h2 id="_3️⃣-ast-abstract-syntax-tree" tabindex="-1"><a class="header-anchor" href="#_3️⃣-ast-abstract-syntax-tree"><span>3️⃣ AST（Abstract Syntax Tree）</span></a></h2><blockquote><p><strong>这是“经典教材”和“工业实现”的第一个分水岭</strong></p></blockquote><h3 id="做什么-2" tabindex="-1"><a class="header-anchor" href="#做什么-2"><span>做什么</span></a></h3><p>从 CST 中<strong>去掉所有“无语义价值”的结构</strong>，保留语义骨架。</p><hr><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><p>CST → AST：</p><ul><li>去掉 <code>(</code> <code>)</code> <code>{}</code> <code>;</code></li><li>折叠表达式层级</li></ul><hr><h3 id="核心技术-2" tabindex="-1"><a class="header-anchor" href="#核心技术-2"><span>核心技术</span></a></h3><ul><li>Tree rewrite</li><li>Visitor / Pattern matching</li><li>Grammar-driven AST or hand-written AST</li></ul><hr><h3 id="工程实现-2" tabindex="-1"><a class="header-anchor" href="#工程实现-2"><span>工程实现</span></a></h3><ul><li>javac AST</li><li>clang AST</li><li>Rust HIR / MIR（多级 AST）</li></ul><hr><h3 id="现实意义-2" tabindex="-1"><a class="header-anchor" href="#现实意义-2"><span>现实意义</span></a></h3><ul><li><strong>后续所有“理解代码”的基础</strong></li><li>比 CST 稳定得多</li></ul><hr><h2 id="_4️⃣-语义分析-semantic-analysis" tabindex="-1"><a class="header-anchor" href="#_4️⃣-语义分析-semantic-analysis"><span>4️⃣ 语义分析（Semantic Analysis）</span></a></h2><h3 id="做什么-3" tabindex="-1"><a class="header-anchor" href="#做什么-3"><span>做什么</span></a></h3><p>回答“<strong>这段代码在逻辑上是否合法</strong>”。</p><hr><h3 id="核心检查" tabindex="-1"><a class="header-anchor" href="#核心检查"><span>核心检查</span></a></h3><ul><li>变量是否声明</li><li>类型是否匹配</li><li>作用域是否合法</li><li>函数/方法调用是否合法</li><li>重载、泛型、trait、interface 解析</li></ul><hr><h3 id="核心技术-3" tabindex="-1"><a class="header-anchor" href="#核心技术-3"><span>核心技术</span></a></h3><ul><li>符号表（Symbol Table）</li><li>作用域链</li><li>类型系统（Type Inference / Checking）</li><li>控制流分析（初步）</li></ul><hr><h3 id="工程实现-3" tabindex="-1"><a class="header-anchor" href="#工程实现-3"><span>工程实现</span></a></h3><ul><li>javac 的 Enter / Attr 阶段</li><li>clang Sema</li><li>Rust borrow checker（语义分析的巅峰形态）</li></ul><hr><h3 id="产物-1" tabindex="-1"><a class="header-anchor" href="#产物-1"><span>产物</span></a></h3><ul><li><strong>带类型和符号信息的 AST</strong></li><li>或新的中间表示</li></ul><hr><h2 id="_5️⃣-中间表示-ir-intermediate-representation" tabindex="-1"><a class="header-anchor" href="#_5️⃣-中间表示-ir-intermediate-representation"><span>5️⃣ 中间表示（IR, Intermediate Representation）</span></a></h2><blockquote><p><strong>这是现代编译器真正的“核心战场”</strong></p></blockquote><h3 id="做什么-4" tabindex="-1"><a class="header-anchor" href="#做什么-4"><span>做什么</span></a></h3><p>把代码转换成<strong>与语言无关、与平台弱相关</strong>的表示。</p><hr><h3 id="常见-ir-形态" tabindex="-1"><a class="header-anchor" href="#常见-ir-形态"><span>常见 IR 形态</span></a></h3><h4 id="_1-三地址码-tac" tabindex="-1"><a class="header-anchor" href="#_1-三地址码-tac"><span>1. 三地址码（TAC）</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>t1 = b + 1</span></span>
<span class="line"><span>a = t1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-ssa-static-single-assignment" tabindex="-1"><a class="header-anchor" href="#_2-ssa-static-single-assignment"><span>2. SSA（Static Single Assignment）</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>t1 = add b, 1</span></span>
<span class="line"><span>a = t1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="核心技术-4" tabindex="-1"><a class="header-anchor" href="#核心技术-4"><span>核心技术</span></a></h3><ul><li>SSA 构建</li><li>控制流图（CFG）</li><li>基本块（Basic Block）</li><li>Dominator Tree</li></ul><hr><h3 id="工程实现-4" tabindex="-1"><a class="header-anchor" href="#工程实现-4"><span>工程实现</span></a></h3><ul><li>LLVM IR</li><li>JVM Bytecode（某种 IR）</li><li>WebAssembly</li><li>Go SSA</li></ul><hr><h3 id="现实意义-3" tabindex="-1"><a class="header-anchor" href="#现实意义-3"><span>现实意义</span></a></h3><ul><li><strong>优化的主要载体</strong></li><li>多语言、多后端复用的关键</li></ul><hr><h2 id="_6️⃣-优化-optimization" tabindex="-1"><a class="header-anchor" href="#_6️⃣-优化-optimization"><span>6️⃣ 优化（Optimization）</span></a></h2><h3 id="做什么-5" tabindex="-1"><a class="header-anchor" href="#做什么-5"><span>做什么</span></a></h3><p>在<strong>不改变语义</strong>的前提下，让程序：</p><ul><li>更快</li><li>更小</li><li>更省资源</li></ul><hr><h3 id="核心优化技术" tabindex="-1"><a class="header-anchor" href="#核心优化技术"><span>核心优化技术</span></a></h3><h4 id="局部优化" tabindex="-1"><a class="header-anchor" href="#局部优化"><span>局部优化</span></a></h4><ul><li>常量折叠</li><li>公共子表达式消除</li><li>死代码消除</li></ul><h4 id="全局优化" tabindex="-1"><a class="header-anchor" href="#全局优化"><span>全局优化</span></a></h4><ul><li>内联</li><li>循环展开</li><li>强度削弱</li><li>Escape Analysis</li></ul><hr><h3 id="工程实现-5" tabindex="-1"><a class="header-anchor" href="#工程实现-5"><span>工程实现</span></a></h3><ul><li>LLVM Pass</li><li>JVM JIT 编译器（C1 / C2）</li><li>GCC Optimization Levels (-O2/-O3)</li></ul><hr><h2 id="_7️⃣-目标代码生成-code-generation" tabindex="-1"><a class="header-anchor" href="#_7️⃣-目标代码生成-code-generation"><span>7️⃣ 目标代码生成（Code Generation）</span></a></h2><h3 id="做什么-6" tabindex="-1"><a class="header-anchor" href="#做什么-6"><span>做什么</span></a></h3><p>把 IR 映射为<strong>目标架构相关的指令</strong>。</p><hr><h3 id="核心技术-5" tabindex="-1"><a class="header-anchor" href="#核心技术-5"><span>核心技术</span></a></h3><ul><li>指令选择（Instruction Selection）</li><li>寄存器分配（Graph Coloring）</li><li>指令调度</li></ul><hr><h3 id="工程实现-6" tabindex="-1"><a class="header-anchor" href="#工程实现-6"><span>工程实现</span></a></h3><ul><li>LLVM backend</li><li>GCC backend</li></ul><hr><h3 id="产物-2" tabindex="-1"><a class="header-anchor" href="#产物-2"><span>产物</span></a></h3><ul><li>汇编代码（Assembly）</li></ul><hr><h2 id="_8️⃣-汇编-assembler" tabindex="-1"><a class="header-anchor" href="#_8️⃣-汇编-assembler"><span>8️⃣ 汇编（Assembler）</span></a></h2><h3 id="做什么-7" tabindex="-1"><a class="header-anchor" href="#做什么-7"><span>做什么</span></a></h3><p>把汇编代码转成<strong>机器指令（二进制）</strong>。</p><hr><h3 id="工程实现-7" tabindex="-1"><a class="header-anchor" href="#工程实现-7"><span>工程实现</span></a></h3><ul><li>as（GNU assembler）</li><li>LLVM MC</li></ul><hr><h2 id="_9️⃣-链接-linker" tabindex="-1"><a class="header-anchor" href="#_9️⃣-链接-linker"><span>9️⃣ 链接（Linker）</span></a></h2><h3 id="做什么-8" tabindex="-1"><a class="header-anchor" href="#做什么-8"><span>做什么</span></a></h3><p>把多个目标文件 + 库：</p><ul><li>合并</li><li>重定位</li><li>解析符号</li></ul><hr><h3 id="核心技术-6" tabindex="-1"><a class="header-anchor" href="#核心技术-6"><span>核心技术</span></a></h3><ul><li>符号解析</li><li>地址重定位</li><li>静态 / 动态链接</li></ul><hr><h3 id="工程实现-8" tabindex="-1"><a class="header-anchor" href="#工程实现-8"><span>工程实现</span></a></h3><ul><li>ld</li><li>lld</li><li>gold</li></ul><hr><h3 id="最终产物" tabindex="-1"><a class="header-anchor" href="#最终产物"><span>最终产物</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>ELF / PE / Mach-O</span></span>
<span class="line"><span>→ 0 和 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="三、不同语言在这条链路中的-变体" tabindex="-1"><a class="header-anchor" href="#三、不同语言在这条链路中的-变体"><span>三、不同语言在这条链路中的“变体”</span></a></h1><h3 id="java-hotspot" tabindex="-1"><a class="header-anchor" href="#java-hotspot"><span>Java（HotSpot）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>.java</span></span>
<span class="line"><span> → AST</span></span>
<span class="line"><span> → Bytecode</span></span>
<span class="line"><span> → JIT</span></span>
<span class="line"><span> → Machine Code</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>JS</span></span>
<span class="line"><span> → AST</span></span>
<span class="line"><span> → IR</span></span>
<span class="line"><span> → JIT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="python" tabindex="-1"><a class="header-anchor" href="#python"><span>Python</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>.py</span></span>
<span class="line"><span> → AST</span></span>
<span class="line"><span> → Bytecode</span></span>
<span class="line"><span> → VM</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h1 id="四、核心技术全景总结-按学科" tabindex="-1"><a class="header-anchor" href="#四、核心技术全景总结-按学科"><span>四、核心技术全景总结（按学科）</span></a></h1><table><thead><tr><th>学科</th><th>技术</th></tr></thead><tbody><tr><td>自动机</td><td>DFA / NFA</td></tr><tr><td>形式语言</td><td>CFG / PEG</td></tr><tr><td>数据结构</td><td>树 / CFG / SSA</td></tr><tr><td>算法</td><td>图算法 / 优化</td></tr><tr><td>系统</td><td>ABI / 指令集</td></tr><tr><td>工程</td><td>增量编译 / JIT</td></tr></tbody></table><hr><h1 id="五、站在你当前关注点的-工程结论" tabindex="-1"><a class="header-anchor" href="#五、站在你当前关注点的-工程结论"><span>五、站在你当前关注点的“工程结论”</span></a></h1><p>结合你近期研究的：</p><ul><li><strong>Tree-sitter</strong></li><li><strong>Code Graph</strong></li><li><strong>RAG</strong></li><li><strong>AI 编程平台</strong></li></ul><p>可以这样定位：</p><blockquote><p><strong>编译器前端（Lexer + CST + AST）是“结构事实层”<br> IR + CFG + Call Graph 是“程序行为层”<br> AI / LLM 是“推理与生成层”</strong></p></blockquote><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/tree-sitter/tree-sitter" target="_blank" rel="noopener noreferrer">https://github.com/tree-sitter/tree-sitter</a></p>`,166)])])}const p=s(l,[["render",r]]),c=JSON.parse('{"path":"/posts/code-graph/2026-01-05-source-code-to-zero-01-intro.html","title":"从源码编译到计算机字节码经历了什么？","lang":"zh-CN","frontmatter":{"title":"从源码编译到计算机字节码经历了什么？","date":"2026-01-05T00:00:00.000Z","categories":["AI"],"tags":["ai","ai-coding","code-graph","sh"],"published":true,"description":"源码===》字节码 下面我会按**“从工程现实出发、同时不失编译原理严谨性”的方式，把经典语言编译从源代码到 0/1 的完整路径系统拆开，并明确每一阶段的输入 / 输出 / 关键技术 / 现实中的实现形态**。 我会刻意区分三条线索： 经典编译理论中的标准流水线 现代工业级编译器的真实形态 你当前关心的 AI / 代码理解 / RAG 体系中，这些阶段...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"从源码编译到计算机字节码经历了什么？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T07:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/code-graph/2026-01-05-source-code-to-zero-01-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"从源码编译到计算机字节码经历了什么？"}],["meta",{"property":"og:description","content":"源码===》字节码 下面我会按**“从工程现实出发、同时不失编译原理严谨性”的方式，把经典语言编译从源代码到 0/1 的完整路径系统拆开，并明确每一阶段的输入 / 输出 / 关键技术 / 现实中的实现形态**。 我会刻意区分三条线索： 经典编译理论中的标准流水线 现代工业级编译器的真实形态 你当前关心的 AI / 代码理解 / RAG 体系中，这些阶段..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T07:44:04.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"code-graph"}],["meta",{"property":"article:tag","content":"ai-coding"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T07:44:04.000Z"}]]},"git":{"createdTime":1767605962000,"updatedTime":1767771844000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":4.45,"words":1335},"filePathRelative":"posts/code-graph/2026-01-05-source-code-to-zero-01-intro.md","excerpt":"\\n<p>下面我会按**“从工程现实出发、同时不失编译原理严谨性”<strong>的方式，把</strong>经典语言编译从源代码到 0/1 的完整路径<strong>系统拆开，并明确每一阶段的</strong>输入 / 输出 / 关键技术 / 现实中的实现形态**。</p>\\n<p>我会刻意区分三条线索：</p>\\n<ol>\\n<li><strong>经典编译理论中的标准流水线</strong></li>\\n<li><strong>现代工业级编译器的真实形态</strong></li>\\n<li><strong>你当前关心的 AI / 代码理解 / RAG 体系中，这些阶段各自的价值</strong></li>\\n</ol>","autoDesc":true}');export{p as comp,c as data};
