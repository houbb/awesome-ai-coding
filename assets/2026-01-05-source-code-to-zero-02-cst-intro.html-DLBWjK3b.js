import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as n,o as i}from"./app-BCq4GIDA.js";const t={};function r(l,s){return i(),e("div",null,[...s[0]||(s[0]=[n(`<h1 id="chat" tabindex="-1"><a class="header-anchor" href="#chat"><span>chat</span></a></h1><h2 id="一、什么是-cst-concrete-syntax-tree" tabindex="-1"><a class="header-anchor" href="#一、什么是-cst-concrete-syntax-tree"><span>一、什么是 CST（Concrete Syntax Tree）</span></a></h2><p><strong>Concrete Syntax Tree（具体语法树）</strong>，也常被称为：</p><ul><li><strong>Parse Tree（解析树）</strong></li><li><strong>Derivation Tree（推导树）</strong></li></ul><p>它是<strong>源代码按照“语言的完整语法规则”解析后得到的树结构</strong>，<strong>完整保留了源代码的所有语法细节</strong>。</p><p>一句话定义：</p><blockquote><p><strong>CST 是对源代码“如何写出来的”这一过程的精确结构化表示。</strong></p></blockquote><p>它严格对应某一门语言的 <strong>BNF / EBNF / PEG 等形式化语法定义</strong>。</p><hr><h2 id="二、cst-的核心特征" tabindex="-1"><a class="header-anchor" href="#二、cst-的核心特征"><span>二、CST 的核心特征</span></a></h2><h3 id="_1-完整保留语法细节" tabindex="-1"><a class="header-anchor" href="#_1-完整保留语法细节"><span>1. 完整保留语法细节</span></a></h3><p>CST 会保留：</p><ul><li><p>所有关键字（<code>if</code>、<code>for</code>、<code>return</code>）</p></li><li><p>所有符号（<code>{ } ( ) ; ,</code>）</p></li><li><p>所有层级结构</p></li><li><p>甚至包括：</p><ul><li>空白（Whitespace）</li><li>换行</li><li>注释（在很多实现中）</li></ul></li></ul><p>也就是说：</p><blockquote><p><strong>只要你能在源码里“看到”的东西，在 CST 里几乎都能找到对应节点。</strong></p></blockquote><hr><h3 id="_2-一一对应语法规则-grammar-driven" tabindex="-1"><a class="header-anchor" href="#_2-一一对应语法规则-grammar-driven"><span>2. 一一对应语法规则（Grammar-driven）</span></a></h3><p>CST 的每一个节点，通常都<strong>直接对应一条语法规则</strong>。</p><p>例如 Java 中的规则：</p><div class="language-ebnf line-numbers-mode" data-highlighter="shiki" data-ext="ebnf" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-ebnf"><span class="line"><span>ifStatement</span></span>
<span class="line"><span>  : &#39;if&#39; &#39;(&#39; expression &#39;)&#39; statement (&#39;else&#39; statement)?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>CST 中就会有：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>ifStatement</span></span>
<span class="line"><span> ├── &#39;if&#39;</span></span>
<span class="line"><span> ├── &#39;(&#39;</span></span>
<span class="line"><span> ├── expression</span></span>
<span class="line"><span> ├── &#39;)&#39;</span></span>
<span class="line"><span> ├── statement</span></span>
<span class="line"><span> └── elseClause?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>没有任何“语义上的简化”。</p><hr><h3 id="_3-强依赖语言版本与语法形式" tabindex="-1"><a class="header-anchor" href="#_3-强依赖语言版本与语法形式"><span>3. 强依赖语言版本与语法形式</span></a></h3><ul><li>Java 8 vs Java 17 → CST 不同</li><li>同一语言，不同 parser 实现 → CST 结构也可能不同</li><li>改一个语法规则 → CST 形态就会变化</li></ul><p>这也是 CST <strong>不稳定但精确</strong>的本质。</p><hr><h2 id="三、cst-vs-ast-抽象语法树" tabindex="-1"><a class="header-anchor" href="#三、cst-vs-ast-抽象语法树"><span>三、CST vs AST（抽象语法树）</span></a></h2><p>这是理解 CST 的关键对比。</p><h3 id="_1-本质区别" tabindex="-1"><a class="header-anchor" href="#_1-本质区别"><span>1. 本质区别</span></a></h3><table><thead><tr><th>维度</th><th>CST</th><th>AST</th></tr></thead><tbody><tr><td>关注点</td><td>语法形式</td><td>语义结构</td></tr><tr><td>保留括号/分号</td><td>是</td><td>否</td></tr><tr><td>是否保留注释</td><td>通常是</td><td>通常否</td></tr><tr><td>节点数量</td><td>非常多</td><td>相对精简</td></tr><tr><td>与 Grammar 绑定</td><td>强</td><td>弱</td></tr><tr><td>是否适合分析含义</td><td>不直接</td><td>非常适合</td></tr></tbody></table><hr><h3 id="_2-一个直观例子" tabindex="-1"><a class="header-anchor" href="#_2-一个直观例子"><span>2. 一个直观例子</span></a></h3><p>源码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> c </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> d</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>CST（简化示意）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>assignment</span></span>
<span class="line"><span> ├── identifier(a)</span></span>
<span class="line"><span> ├── &#39;=&#39;</span></span>
<span class="line"><span> └── expression</span></span>
<span class="line"><span>     ├── expression</span></span>
<span class="line"><span>     │   ├── identifier(b)</span></span>
<span class="line"><span>     │   ├── &#39;+&#39;</span></span>
<span class="line"><span>     │   └── expression</span></span>
<span class="line"><span>     │       ├── identifier(c)</span></span>
<span class="line"><span>     │       ├── &#39;*&#39;</span></span>
<span class="line"><span>     │       └── identifier(d)</span></span>
<span class="line"><span>     └── &#39;;&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>AST（简化示意）</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Assign</span></span>
<span class="line"><span> ├── Var(a)</span></span>
<span class="line"><span> └── Add</span></span>
<span class="line"><span>     ├── Var(b)</span></span>
<span class="line"><span>     └── Mul</span></span>
<span class="line"><span>         ├── Var(c)</span></span>
<span class="line"><span>         └── Var(d)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到：</p><ul><li>AST 把 <strong>“怎么写”</strong> 抽象成 <strong>“是什么”</strong></li><li>CST 则忠实反映 <strong>“源码长什么样”</strong></li></ul><hr><h2 id="四、cst-是如何构建的" tabindex="-1"><a class="header-anchor" href="#四、cst-是如何构建的"><span>四、CST 是如何构建的</span></a></h2><h3 id="_1-构建流程" tabindex="-1"><a class="header-anchor" href="#_1-构建流程"><span>1. 构建流程</span></a></h3><p>典型编译前端流程：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Source Code</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>Lexer（词法分析）</span></span>
<span class="line"><span>   ↓ Tokens</span></span>
<span class="line"><span>Parser（语法分析）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>Concrete Syntax Tree（CST）</span></span>
<span class="line"><span>   ↓</span></span>
<span class="line"><span>AST / IR / Semantic Analysis</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CST <strong>就是 Parser 的直接产物</strong>。</p><hr><h3 id="_2-常见-cst-构建工具" tabindex="-1"><a class="header-anchor" href="#_2-常见-cst-构建工具"><span>2. 常见 CST 构建工具</span></a></h3><p>你最近翻译、关注过的一些工具，实际上就是 CST 的代表：</p><h4 id="tree-sitter-你最近刚接触" tabindex="-1"><a class="header-anchor" href="#tree-sitter-你最近刚接触"><span>Tree-sitter（你最近刚接触）</span></a></h4><ul><li>增量解析</li><li>直接生成 CST</li><li>每个 grammar 对应非常稳定的节点类型</li><li>极度适合编辑器、IDE、代码搜索、代码图谱</li></ul><h4 id="antlr" tabindex="-1"><a class="header-anchor" href="#antlr"><span>ANTLR</span></a></h4><ul><li>默认生成 Parse Tree（本质就是 CST）</li><li>可在此基础上构建 AST</li></ul><h4 id="javacc-bison-yacc" tabindex="-1"><a class="header-anchor" href="#javacc-bison-yacc"><span>JavaCC / Bison / Yacc</span></a></h4><ul><li>都是 Grammar → CST 的典型路径</li></ul><hr><h2 id="五、为什么要有-cst-它解决了什么问题" tabindex="-1"><a class="header-anchor" href="#五、为什么要有-cst-它解决了什么问题"><span>五、为什么要有 CST？它解决了什么问题？</span></a></h2><p>这是你前面那个“为什么又绕回语法树”的核心问题。</p><h3 id="_1-代码不是只有-语义-还有-形式" tabindex="-1"><a class="header-anchor" href="#_1-代码不是只有-语义-还有-形式"><span>1. <strong>代码不是只有“语义”，还有“形式”</strong></span></a></h3><p>很多场景，<strong>形式本身就是信息</strong>：</p><ul><li>代码格式化（formatter）</li><li>精准重构（不破坏注释、换行）</li><li>Lint / 静态规则扫描</li><li>Patch / Diff / Code Review</li><li>代码结构可视化</li></ul><p>👉 <strong>AST 无法还原原始代码，CST 可以。</strong></p><hr><h3 id="_2-编辑器与-ide-必须使用-cst" tabindex="-1"><a class="header-anchor" href="#_2-编辑器与-ide-必须使用-cst"><span>2. 编辑器与 IDE 必须使用 CST</span></a></h3><p>IDE 关心的是：</p><ul><li>光标在哪个 token 上</li><li>少写一个 <code>)</code> 是否还能解析</li><li>实时高亮</li><li>增量更新（只解析你改的那一行）</li></ul><p>这些都<strong>严重依赖 CST</strong>：</p><blockquote><p><strong>AST 是“事后分析”，CST 是“实时编辑友好”。</strong></p></blockquote><p>Tree-sitter 的成功，正是因为 CST + 增量解析。</p><hr><h3 id="_3-对-ai-rag-code-graph-极其重要" tabindex="-1"><a class="header-anchor" href="#_3-对-ai-rag-code-graph-极其重要"><span>3. 对 AI / RAG / Code Graph 极其重要</span></a></h3><p>结合你最近研究的 <strong>Code Graph / RAG</strong>，CST 的价值非常现实：</p><ul><li>CST → 精确定位符号出现位置</li><li>CST → 保留上下文边界（文件、块、作用域）</li><li>CST → 稳定的“结构切分单元”</li></ul><p>这正是为什么：</p><ul><li><strong>Code Graph RAG</strong></li><li><strong>结构化代码切片</strong></li><li><strong>可回溯的代码引用</strong></li></ul><p>都更偏向 <strong>CST / CST 派生结构</strong>，而不是纯 AST。</p><hr><h2 id="六、cst-的局限性" tabindex="-1"><a class="header-anchor" href="#六、cst-的局限性"><span>六、CST 的局限性</span></a></h2><p>CST 并不是银弹。</p><h3 id="_1-结构冗余、节点多" tabindex="-1"><a class="header-anchor" href="#_1-结构冗余、节点多"><span>1. 结构冗余、节点多</span></a></h3><ul><li>一个简单表达式 → 十几个节点</li><li>不适合直接做“语义推理”</li></ul><h3 id="_2-跨语言难统一" tabindex="-1"><a class="header-anchor" href="#_2-跨语言难统一"><span>2. 跨语言难统一</span></a></h3><ul><li>Java CST ≠ Python CST</li><li>结构差异大，不利于通用分析</li></ul><h3 id="_3-不能直接表达-含义" tabindex="-1"><a class="header-anchor" href="#_3-不能直接表达-含义"><span>3. 不能直接表达“含义”</span></a></h3><p>例如：</p><ul><li>变量是否被使用</li><li>类型推导</li><li>调用关系</li></ul><p>这些必须在 <strong>AST / IR / Symbol Table</strong> 层完成。</p><hr><h2 id="七、现代工具链中的定位总结" tabindex="-1"><a class="header-anchor" href="#七、现代工具链中的定位总结"><span>七、现代工具链中的定位总结</span></a></h2><p>一句话总结 CST 的位置：</p><blockquote><p><strong>CST 是“代码结构的事实层”，AST 是“代码语义的解释层”。</strong></p></blockquote><p>在现代系统中，常见组合是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>CST</span></span>
<span class="line"><span> ├── 精准定位 / 编辑 / 可视化</span></span>
<span class="line"><span> ├── 代码切片 / RAG chunk</span></span>
<span class="line"><span> └── AST / IR / Code Graph</span></span>
<span class="line"><span>        ├── 语义分析</span></span>
<span class="line"><span>        ├── 调用关系</span></span>
<span class="line"><span>        └── 推理与优化</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="八、一句-工程视角-的结论" tabindex="-1"><a class="header-anchor" href="#八、一句-工程视角-的结论"><span>八、一句“工程视角”的结论</span></a></h2><p>站在你这样的工程 / 架构视角，可以这样理解：</p><blockquote><p><strong>AI 负责“理解与推理”，CST 负责“结构与锚点”。<br> 没有 CST，AI 很难做到稳定、可回溯、可解释地理解代码。</strong></p></blockquote><p>如果你愿意，下一步我可以帮你：</p><ul><li>用 <strong>Tree-sitter + Java</strong> 举一个完整 CST 示例</li><li>解释 <strong>CST → Code Graph → RAG</strong> 的工程级流水线</li><li>对比 <strong>AST / CST / Token</strong> 在 AI 编程中的分工</li></ul><p>你可以直接指定你更关心哪一块。</p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://github.com/tree-sitter/tree-sitter" target="_blank" rel="noopener noreferrer">https://github.com/tree-sitter/tree-sitter</a></p>`,104)])])}const c=a(t,[["render",r]]),o=JSON.parse('{"path":"/posts/code-graph/2026-01-05-source-code-to-zero-02-cst-intro.html","title":"具体语法树（Concrete Syntax Tree, CST）","lang":"zh-CN","frontmatter":{"title":"具体语法树（Concrete Syntax Tree, CST）","date":"2026-01-05T00:00:00.000Z","categories":["AI"],"tags":["ai","ai-coding","code-graph","sh"],"published":true,"description":"chat 一、什么是 CST（Concrete Syntax Tree） Concrete Syntax Tree（具体语法树），也常被称为： Parse Tree（解析树） Derivation Tree（推导树） 它是源代码按照“语言的完整语法规则”解析后得到的树结构，完整保留了源代码的所有语法细节。 一句话定义： CST 是对源代码“如何写出来的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"具体语法树（Concrete Syntax Tree, CST）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-05T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-07T07:44:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/code-graph/2026-01-05-source-code-to-zero-02-cst-intro.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"具体语法树（Concrete Syntax Tree, CST）"}],["meta",{"property":"og:description","content":"chat 一、什么是 CST（Concrete Syntax Tree） Concrete Syntax Tree（具体语法树），也常被称为： Parse Tree（解析树） Derivation Tree（推导树） 它是源代码按照“语言的完整语法规则”解析后得到的树结构，完整保留了源代码的所有语法细节。 一句话定义： CST 是对源代码“如何写出来的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-07T07:44:04.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"code-graph"}],["meta",{"property":"article:tag","content":"ai-coding"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:published_time","content":"2026-01-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-07T07:44:04.000Z"}]]},"git":{"createdTime":1767605962000,"updatedTime":1767771844000,"contributors":[{"name":"binbin.hou","username":"","email":"binbin.hou@huifu.com","commits":2}]},"readingTime":{"minutes":4.45,"words":1336},"filePathRelative":"posts/code-graph/2026-01-05-source-code-to-zero-02-cst-intro.md","excerpt":"\\n<h2>一、什么是 CST（Concrete Syntax Tree）</h2>\\n<p><strong>Concrete Syntax Tree（具体语法树）</strong>，也常被称为：</p>\\n<ul>\\n<li><strong>Parse Tree（解析树）</strong></li>\\n<li><strong>Derivation Tree（推导树）</strong></li>\\n</ul>\\n<p>它是<strong>源代码按照“语言的完整语法规则”解析后得到的树结构</strong>，<strong>完整保留了源代码的所有语法细节</strong>。</p>\\n<p>一句话定义：</p>","autoDesc":true}');export{c as comp,o as data};
