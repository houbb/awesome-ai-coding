import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as i}from"./app-Br9pe4tt.js";const r={};function t(l,a){return i(),s("div",null,[...a[0]||(a[0]=[n(`<h1 id="如何拆分巨大的详细设计" tabindex="-1"><a class="header-anchor" href="#如何拆分巨大的详细设计"><span>如何拆分巨大的详细设计?</span></a></h1><p>这是一个<strong>架构与认知层面的问题</strong>，不是“文档排版技巧”，而是<strong>如何把一个“大而混”的详细设计，拆成 AI 与人都能稳定执行的“最小认知单元”</strong>。</p><p>我从 <strong>拆分原则 → 常见拆分维度 → 可操作拆分技巧 → 一个完整示例</strong> 四个层面回答。</p><hr><h2 id="一、先给结论-详细设计-变大-的根因是什么" tabindex="-1"><a class="header-anchor" href="#一、先给结论-详细设计-变大-的根因是什么"><span>一、先给结论：详细设计“变大”的根因是什么？</span></a></h2><blockquote><p><strong>不是功能多，而是“维度混叠”。</strong></p></blockquote><p>一个设计之所以显得“巨大”，通常是因为在同一份文档里<strong>同时讨论了</strong>：</p><ul><li>做什么（What）</li><li>为什么（Why）</li><li>怎么做（How）</li><li>谁负责（Who）</li><li>异常怎么办（Edge / Risk）</li><li>与哪些系统交互（Integration）</li></ul><p><strong>人和 AI 都会被迫在多个维度来回切换，认知负载指数级上升。</strong></p><p>拆分的目标不是“切碎”，而是<strong>一维一文档、一文档一目的</strong>。</p><hr><h2 id="二、拆分的第一性原则-非常重要" tabindex="-1"><a class="header-anchor" href="#二、拆分的第一性原则-非常重要"><span>二、拆分的第一性原则（非常重要）</span></a></h2><h3 id="原则-1-一个文档只回答一个核心问题" tabindex="-1"><a class="header-anchor" href="#原则-1-一个文档只回答一个核心问题"><span>原则 1：一个文档只回答一个核心问题</span></a></h3><table><thead><tr><th>文档类型</th><th>只回答</th></tr></thead><tbody><tr><td><a href="http://OVERVIEW.md" target="_blank" rel="noopener noreferrer">OVERVIEW.md</a></td><td>这个需求是什么、边界在哪里</td></tr><tr><td><a href="http://FLOW.md" target="_blank" rel="noopener noreferrer">FLOW.md</a></td><td>流程如何走</td></tr><tr><td><a href="http://DATA.md" target="_blank" rel="noopener noreferrer">DATA.md</a></td><td>数据怎么变</td></tr><tr><td><a href="http://INTERFACE.md" target="_blank" rel="noopener noreferrer">INTERFACE.md</a></td><td>外部怎么调用</td></tr><tr><td><a href="http://RULES.md" target="_blank" rel="noopener noreferrer">RULES.md</a></td><td>业务规则是什么</td></tr><tr><td><a href="http://EXCEPTION.md" target="_blank" rel="noopener noreferrer">EXCEPTION.md</a></td><td>异常与兜底</td></tr><tr><td><a href="http://RISK.md" target="_blank" rel="noopener noreferrer">RISK.md</a></td><td>风险与不确定性</td></tr></tbody></table><p><strong>禁止</strong>在一个文档里“顺带提一下另一个维度”。</p><hr><h3 id="原则-2-拆分不是-分页-而是-解耦关注点" tabindex="-1"><a class="header-anchor" href="#原则-2-拆分不是-分页-而是-解耦关注点"><span>原则 2：拆分不是“分页”，而是“解耦关注点”</span></a></h3><p>错误的拆分：</p><ul><li>第 1～10 页：设计说明</li><li>第 11～20 页：设计说明（续）</li></ul><p>正确的拆分：</p><ul><li>主流程一份</li><li>数据一份</li><li>异常一份</li></ul><hr><h3 id="原则-3-主文档必须-轻-重内容全部下沉" tabindex="-1"><a class="header-anchor" href="#原则-3-主文档必须-轻-重内容全部下沉"><span>原则 3：主文档必须“轻”，重内容全部下沉</span></a></h3><p>主设计文档（<a href="http://DESIGN.md" target="_blank" rel="noopener noreferrer">DESIGN.md</a>）应该满足：</p><blockquote><p><strong>10 分钟能看完 + 不需要滚动太多</strong></p></blockquote><p>否则必拆。</p><hr><h2 id="三、六种-稳定有效-的拆分维度-可组合使用" tabindex="-1"><a class="header-anchor" href="#三、六种-稳定有效-的拆分维度-可组合使用"><span>三、六种“稳定有效”的拆分维度（可组合使用）</span></a></h2><p>下面这些，是我在<strong>复杂系统、历史包袱项目、AI 编程场景中最稳定的拆分方式</strong>。</p><hr><h3 id="_1️⃣-按「认知阶段」拆分-最通用" tabindex="-1"><a class="header-anchor" href="#_1️⃣-按「认知阶段」拆分-最通用"><span>1️⃣ 按「认知阶段」拆分（最通用）</span></a></h3><p>把设计拆成<strong>人理解的顺序</strong>：</p><ol><li><p><a href="http://OVERVIEW.md" target="_blank" rel="noopener noreferrer">OVERVIEW.md</a></p><ul><li>目标</li><li>非目标</li><li>成功标准</li></ul></li><li><p><a href="http://FLOW.md" target="_blank" rel="noopener noreferrer">FLOW.md</a></p><ul><li>主流程</li><li>子流程</li><li>状态流转</li></ul></li><li><p><a href="http://DETAIL.md" target="_blank" rel="noopener noreferrer">DETAIL.md</a></p><ul><li>每一步如何实现</li></ul></li></ol><p><strong>适合：</strong></p><ul><li>新功能</li><li>跨团队协作</li><li>AI 先读文档再写代码</li></ul><hr><h3 id="_2️⃣-按「流程主干-vs-分支」拆分" tabindex="-1"><a class="header-anchor" href="#_2️⃣-按「流程主干-vs-分支」拆分"><span>2️⃣ 按「流程主干 vs 分支」拆分</span></a></h3><p>规则：</p><blockquote><p><strong>主流程独立成文档，任何 if / else 都不许出现在主流程文档中</strong></p></blockquote><p>结构示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>DESIGN/</span></span>
<span class="line"><span> ├── FLOW_MAIN.md</span></span>
<span class="line"><span> ├── FLOW_REFUND.md</span></span>
<span class="line"><span> ├── FLOW_RETRY.md</span></span>
<span class="line"><span> ├── FLOW_TIMEOUT.md</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>好处：</strong></p><ul><li>主流程极其清晰</li><li>分支可以单独演进</li><li>AI 不会在主路径里迷路</li></ul><hr><h3 id="_3️⃣-按「数据视角」拆分-强烈推荐" tabindex="-1"><a class="header-anchor" href="#_3️⃣-按「数据视角」拆分-强烈推荐"><span>3️⃣ 按「数据视角」拆分（强烈推荐）</span></a></h3><p>很多“文档很大”的项目，本质是<strong>数据变化写得到处都是</strong>。</p><p>正确方式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>DATA/</span></span>
<span class="line"><span> ├── MODEL.md        # 核心模型</span></span>
<span class="line"><span> ├── STATE.md        # 状态机</span></span>
<span class="line"><span> ├── MIGRATION.md   # 变更影响</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在流程文档中只写：</p><blockquote><p>“此步骤导致 Order 状态从 PAID → SHIPPED（详见 DATA/STATE.md）”</p></blockquote><hr><h3 id="_4️⃣-按「稳定性」拆分-ai-非常吃这一套" tabindex="-1"><a class="header-anchor" href="#_4️⃣-按「稳定性」拆分-ai-非常吃这一套"><span>4️⃣ 按「稳定性」拆分（AI 非常吃这一套）</span></a></h3><table><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td><a href="http://STABLE.md" target="_blank" rel="noopener noreferrer">STABLE.md</a></td><td>几乎不会变</td></tr><tr><td><a href="http://VARIABLE.md" target="_blank" rel="noopener noreferrer">VARIABLE.md</a></td><td>高频变化</td></tr><tr><td><a href="http://EXPERIMENT.md" target="_blank" rel="noopener noreferrer">EXPERIMENT.md</a></td><td>不确定</td></tr></tbody></table><p>AI 执行顺序：</p><ol><li>锁定 STABLE</li><li>重点关注 VARIABLE</li><li>对 EXPERIMENT 保守实现</li></ol><p><strong>这是降低 AI 发散的关键技巧。</strong></p><hr><h3 id="_5️⃣-按「角色-职责」拆分-复杂协作系统" tabindex="-1"><a class="header-anchor" href="#_5️⃣-按「角色-职责」拆分-复杂协作系统"><span>5️⃣ 按「角色 / 职责」拆分（复杂协作系统）</span></a></h3><p>例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>DESIGN/</span></span>
<span class="line"><span> ├── USER_FLOW.md</span></span>
<span class="line"><span> ├── ADMIN_FLOW.md</span></span>
<span class="line"><span> ├── SYSTEM_FLOW.md</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>SERVICE/</span></span>
<span class="line"><span> ├── ORDER_SERVICE.md</span></span>
<span class="line"><span> ├── PAYMENT_SERVICE.md</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>每个文档只描述“该角色 / 该服务视角下的世界”。</strong></p><hr><h3 id="_6️⃣-按「风险密度」拆分-非常适合历史系统" tabindex="-1"><a class="header-anchor" href="#_6️⃣-按「风险密度」拆分-非常适合历史系统"><span>6️⃣ 按「风险密度」拆分（非常适合历史系统）</span></a></h3><p>把<strong>风险最高的部分单独拎出来</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>RISK/</span></span>
<span class="line"><span> ├── LEGACY_COMPAT.md</span></span>
<span class="line"><span> ├── DATA_CORRUPTION.md</span></span>
<span class="line"><span> ├── PERFORMANCE.md</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主设计文档只引用，不展开。</p><hr><h2 id="四、几个-立竿见影-的拆分技巧-很实用" tabindex="-1"><a class="header-anchor" href="#四、几个-立竿见影-的拆分技巧-很实用"><span>四、几个“立竿见影”的拆分技巧（很实用）</span></a></h2><h3 id="技巧-1-超过-3-层标题-立即拆" tabindex="-1"><a class="header-anchor" href="#技巧-1-超过-3-层标题-立即拆"><span>技巧 1：超过 3 层标题，立即拆</span></a></h3><p>如果你看到：</p><div class="language-md line-numbers-mode" data-highlighter="shiki" data-ext="md" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-md"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">### 3.2.1.4 xxx 场景下的处理</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是一个<strong>确定的拆分信号</strong>。</p><hr><h3 id="技巧-2-凡是-重复出现的词-都该独立成文档" tabindex="-1"><a class="header-anchor" href="#技巧-2-凡是-重复出现的词-都该独立成文档"><span>技巧 2：凡是“重复出现的词”，都该独立成文档</span></a></h3><p>例如：</p><ul><li>“状态”</li><li>“幂等”</li><li>“重试”</li><li>“补偿”</li></ul><p>出现 3 次以上，说明这是一个独立关注点。</p><hr><h3 id="技巧-3-流程图和文字分家" tabindex="-1"><a class="header-anchor" href="#技巧-3-流程图和文字分家"><span>技巧 3：流程图和文字分家</span></a></h3><ul><li>流程图：<a href="http://FLOW.md" target="_blank" rel="noopener noreferrer">FLOW.md</a></li><li>文字说明：<a href="http://DETAIL.md" target="_blank" rel="noopener noreferrer">DETAIL.md</a></li></ul><p>不要混在一起。</p><hr><h3 id="技巧-4-让-ai-帮你-找拆分点" tabindex="-1"><a class="header-anchor" href="#技巧-4-让-ai-帮你-找拆分点"><span>技巧 4：让 AI 帮你“找拆分点”</span></a></h3><p>一个非常好用的提示词：</p><blockquote><p>“请识别以下设计中混合的不同关注点，并给出可拆分的文档结构建议。”</p></blockquote><p>AI 在<strong>结构分析</strong>上比人稳定。</p><hr><h2 id="五、一个-从大到小-的完整示例" tabindex="-1"><a class="header-anchor" href="#五、一个-从大到小-的完整示例"><span>五、一个“从大到小”的完整示例</span></a></h2><h3 id="原始状态-典型问题" tabindex="-1"><a class="header-anchor" href="#原始状态-典型问题"><span>原始状态（典型问题）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>DESIGN.md（30 页）</span></span>
<span class="line"><span>- 背景</span></span>
<span class="line"><span>- 接口</span></span>
<span class="line"><span>- 流程</span></span>
<span class="line"><span>- 状态</span></span>
<span class="line"><span>- 异常</span></span>
<span class="line"><span>- 补偿</span></span>
<span class="line"><span>- 风控</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="拆分后" tabindex="-1"><a class="header-anchor" href="#拆分后"><span>拆分后</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>DESIGN/</span></span>
<span class="line"><span> ├── README.md           # 总入口（必读）</span></span>
<span class="line"><span> ├── OVERVIEW.md</span></span>
<span class="line"><span> ├── FLOW_MAIN.md</span></span>
<span class="line"><span> ├── FLOW_EXCEPTION.md</span></span>
<span class="line"><span> ├── DATA_MODEL.md</span></span>
<span class="line"><span> ├── STATE_MACHINE.md</span></span>
<span class="line"><span> ├── INTERFACE.md</span></span>
<span class="line"><span> ├── RISK.md</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><a href="http://README.md" target="_blank" rel="noopener noreferrer">README.md</a> 只做导航，不承载细节。</strong></p><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1>`,97)])])}const h=e(r,[["render",t]]),o=JSON.parse('{"path":"/posts/sdd/2025-11-20-ai-sdd-35-how-to-split.html","title":"AI SDD 开发规范-35-如何拆分巨大的详细设计?","lang":"zh-CN","frontmatter":{"title":"AI SDD 开发规范-35-如何拆分巨大的详细设计?","tags":["ai","sdd","sh"],"published":true,"description":"如何拆分巨大的详细设计? 这是一个架构与认知层面的问题，不是“文档排版技巧”，而是如何把一个“大而混”的详细设计，拆成 AI 与人都能稳定执行的“最小认知单元”。 我从 拆分原则 → 常见拆分维度 → 可操作拆分技巧 → 一个完整示例 四个层面回答。 一、先给结论：详细设计“变大”的根因是什么？ 不是功能多，而是“维度混叠”。 一个设计之所以显得“巨大...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"AI SDD 开发规范-35-如何拆分巨大的详细设计?\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-27T07:27:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://houbb.github.io/awesome-ai-coding/posts/sdd/2025-11-20-ai-sdd-35-how-to-split.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"AI SDD 开发规范-35-如何拆分巨大的详细设计?"}],["meta",{"property":"og:description","content":"如何拆分巨大的详细设计? 这是一个架构与认知层面的问题，不是“文档排版技巧”，而是如何把一个“大而混”的详细设计，拆成 AI 与人都能稳定执行的“最小认知单元”。 我从 拆分原则 → 常见拆分维度 → 可操作拆分技巧 → 一个完整示例 四个层面回答。 一、先给结论：详细设计“变大”的根因是什么？ 不是功能多，而是“维度混叠”。 一个设计之所以显得“巨大..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-27T07:27:41.000Z"}],["meta",{"property":"article:tag","content":"sh"}],["meta",{"property":"article:tag","content":"sdd"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:modified_time","content":"2025-12-27T07:27:41.000Z"}]]},"git":{"createdTime":1766820461000,"updatedTime":1766820461000,"contributors":[{"name":"bbhou","username":"bbhou","email":"1557740299@qq.com","commits":1,"url":"https://github.com/bbhou"}]},"readingTime":{"minutes":3.82,"words":1145},"filePathRelative":"posts/sdd/2025-11-20-ai-sdd-35-how-to-split.md","excerpt":"\\n<p>这是一个<strong>架构与认知层面的问题</strong>，不是“文档排版技巧”，而是<strong>如何把一个“大而混”的详细设计，拆成 AI 与人都能稳定执行的“最小认知单元”</strong>。</p>\\n<p>我从 <strong>拆分原则 → 常见拆分维度 → 可操作拆分技巧 → 一个完整示例</strong> 四个层面回答。</p>\\n<hr>\\n<h2>一、先给结论：详细设计“变大”的根因是什么？</h2>\\n<blockquote>\\n<p><strong>不是功能多，而是“维度混叠”。</strong></p>\\n</blockquote>\\n<p>一个设计之所以显得“巨大”，通常是因为在同一份文档里<strong>同时讨论了</strong>：</p>","autoDesc":true}');export{h as comp,o as data};
